var documenterSearchIndex = {"docs":
[{"location":"advanced/topologies/#Network-Topologies","page":"Network Topologies","title":"Network Topologies","text":"StochProtocol.jl supports various network topologies to model realistic communication structures in distributed systems.","category":"section"},{"location":"advanced/topologies/#Overview","page":"Network Topologies","title":"Overview","text":"By default, protocols assume a complete graph where all processes can communicate with all others. However, real distributed systems often have restricted communication patterns due to network structure.\n\nThe Topologies module allows you to specify these constraints.","category":"section"},{"location":"advanced/topologies/#Available-Topologies","page":"Network Topologies","title":"Available Topologies","text":"","category":"section"},{"location":"advanced/topologies/#CompleteGraph","page":"Network Topologies","title":"CompleteGraph","text":"using StochProtocol\n\n# Default: all processes connected\nresults = run_protocol(protocol;\n    topology = CompleteGraph(),\n    n_processes = 10\n)\n\nAll processes can communicate with all others. This is the default if no topology is specified.","category":"section"},{"location":"advanced/topologies/#Ring","page":"Network Topologies","title":"Ring","text":"# Ring topology: each process talks to neighbors\nresults = run_protocol(protocol;\n    topology = Ring(),\n    n_processes = 10\n)\n\nEach process can only communicate with its two neighbors in a circular arrangement.\n\nUse case: Token-ring networks, circular consensus algorithms.","category":"section"},{"location":"advanced/topologies/#Star","page":"Network Topologies","title":"Star","text":"# Star topology: hub-and-spoke\nresults = run_protocol(protocol;\n    topology = Star(),\n    n_processes = 10\n)\n\nProcess 1 acts as a hub connected to all others. Spoke processes can only communicate with the hub.\n\nUse case: Client-server architectures, coordinator-based protocols.","category":"section"},{"location":"advanced/topologies/#Grid","page":"Network Topologies","title":"Grid","text":"# 2D grid topology\nresults = run_protocol(protocol;\n    topology = Grid(4, 4),  # 4√ó4 grid, 16 processes total\n)\n\nProcesses arranged in a 2D grid with connections to immediate neighbors (up, down, left, right).\n\nUse case: Sensor networks, mesh networks, spatial coordination.","category":"section"},{"location":"advanced/topologies/#RandomGraph","page":"Network Topologies","title":"RandomGraph","text":"# Erd≈ës-R√©nyi random graph\nresults = run_protocol(protocol;\n    topology = RandomGraph(0.3),  # Each edge exists with 30% probability\n    n_processes = 20\n)\n\nEach pair of processes has an edge with probability edge_prob.\n\nUse case: Peer-to-peer networks, random connectivity patterns.","category":"section"},{"location":"advanced/topologies/#KRegular","page":"Network Topologies","title":"KRegular","text":"# k-regular graph: each node has exactly k neighbors\nresults = run_protocol(protocol;\n    topology = KRegular(3),  # Each process has 3 neighbors\n    n_processes = 10\n)\n\nEach process has exactly k neighbors.\n\nUse case: Structured overlay networks, degree-constrained systems.","category":"section"},{"location":"advanced/topologies/#BipartiteGraph","page":"Network Topologies","title":"BipartiteGraph","text":"# Bipartite graph: two disjoint sets\nresults = run_protocol(protocol;\n    topology = BipartiteGraph(5, 5),  # 5 left, 5 right\n)\n\nTwo disjoint groups with connections only between groups, none within.\n\nUse case: Two-layer systems, client-server clusters.","category":"section"},{"location":"advanced/topologies/#CustomTopology","page":"Network Topologies","title":"CustomTopology","text":"# Define custom adjacency matrix\nadj = [false true  false;\n       true  false true;\n       false true  false]\n\nresults = run_protocol(protocol;\n    topology = CustomTopology(adj),\n)\n\nSpecify exact connectivity using an adjacency matrix.\n\nUse case: Specific network structures, hierarchical topologies.","category":"section"},{"location":"advanced/topologies/#Topology-Analysis","page":"Network Topologies","title":"Topology Analysis","text":"","category":"section"},{"location":"advanced/topologies/#Query-Neighbors","page":"Network Topologies","title":"Query Neighbors","text":"topo = Ring()\nn_processes = 10\n\n# Get neighbors of process 5\nnbrs = neighbors(topo, 5, n_processes)\n# Returns: [4, 6]","category":"section"},{"location":"advanced/topologies/#Check-Connectivity","page":"Network Topologies","title":"Check Connectivity","text":"# Can process 2 communicate with process 7?\ncan_communicate(topo, 2, 7, n_processes)","category":"section"},{"location":"advanced/topologies/#Compute-Diameter","page":"Network Topologies","title":"Compute Diameter","text":"# Maximum shortest path distance\nd = diameter(topo, n_processes)\n\n# For Ring with 10 processes: d = 5\n# For CompleteGraph: d = 1\n# For Star: d = 2","category":"section"},{"location":"advanced/topologies/#Visualize-Topology","page":"Network Topologies","title":"Visualize Topology","text":"visualize_topology(Ring(), 5)\n\nPrints ASCII representation of the topology structure.","category":"section"},{"location":"advanced/topologies/#Example:-Comparing-Topologies","page":"Network Topologies","title":"Example: Comparing Topologies","text":"using StochProtocol\n\nprotocol = Protocol(\"\"\"\nPROTOCOL AveragingProtocol\nPROCESSES: 20\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS:\n    discrepancy\n\"\"\")\n\n# Compare different topologies\ntopologies = [\n    (\"Complete\", CompleteGraph()),\n    (\"Ring\", Ring()),\n    (\"Grid 4√ó5\", Grid(4, 5)),\n    (\"3-Regular\", KRegular(3))\n]\n\nfor (name, topo) in topologies\n    results = run_protocol(protocol;\n        topology = topo,\n        p_values = [0.7],\n        rounds = 30,\n        repetitions = 1000\n    )\n\n    println(\"$name topology:\")\n    println(\"  Diameter: \", diameter(topo, 20))\n    results_table(results)\n    println()\nend","category":"section"},{"location":"advanced/topologies/#Impact-on-Convergence","page":"Network Topologies","title":"Impact on Convergence","text":"Topology significantly affects convergence speed:\n\nComplete graphs: Fastest convergence (diameter = 1)\nRing: Slowest convergence (diameter = n/2)\nGrid: Moderate convergence (diameter = 2‚àön approximately)\nStar: Fast convergence (diameter = 2) but hub bottleneck\n\nThe relationship between diameter and convergence is typically:\n\nExpected rounds ‚âà O(diameter / p)\n\nwhere p is the communication probability.","category":"section"},{"location":"advanced/convergence/#Convergence-Analysis","page":"Convergence Analysis","title":"Convergence Analysis","text":"Advanced metrics and analysis tools for understanding protocol convergence behavior.","category":"section"},{"location":"advanced/convergence/#Overview","page":"Convergence Analysis","title":"Overview","text":"Beyond basic discrepancy tracking, the ConvergenceAnalysis module provides sophisticated metrics to characterize convergence speed, stability, and probabilistic guarantees.","category":"section"},{"location":"advanced/convergence/#Convergence-Rate","page":"Convergence Analysis","title":"Convergence Rate","text":"Estimate exponential decay rate of discrepancy.\n\nusing StochProtocol\n\nresults = run_protocol(protocol;\n    p_values = [0.7],\n    rounds = 30,\n    repetitions = 1000\n)\n\n# Extract discrepancy trajectory\ndiscrepancies = results[1].discrepancy_trace\n\n# Compute convergence rate Œª\n# Discrepancy follows: D(t) ‚âà D‚ÇÄ exp(-Œªt)\nŒª = convergence_rate(discrepancies)\n\nprintln(\"Convergence rate: $Œª\")\nprintln(\"Half-life: $(log(2)/Œª) rounds\")\n\nInterpretation:\n\nHigher Œª = faster convergence\nŒª ‚âà 0 = no convergence\nHalf-life = rounds to reduce discrepancy by 50%","category":"section"},{"location":"advanced/convergence/#Time-to-Œµ-Consensus","page":"Convergence Analysis","title":"Time to Œµ-Consensus","text":"Find when discrepancy drops below threshold.\n\n# Rounds to reach 0.01-consensus\nŒµ = 0.01\nt_consensus = time_to_epsilon_consensus(discrepancies, Œµ)\n\nprintln(\"Reached Œµ=$Œµ at round: $t_consensus\")\n\nReturns -1 if never achieved.","category":"section"},{"location":"advanced/convergence/#Stability-Metric","page":"Convergence Analysis","title":"Stability Metric","text":"Measure consistency across multiple runs.\n\n# Run multiple times\nall_trajectories = []\nfor i in 1:100\n    result = run_protocol(protocol; p=0.7, rounds=20, seed=UInt32(i))\n    push!(all_trajectories, result.discrepancy_trace)\nend\n\n# Compute stability (lower = more consistent)\nstability = stability_metric(all_trajectories)\n\nprintln(\"Stability score: $stability\")\n\nInterpretation:\n\nLow stability = consistent behavior across runs\nHigh stability = high variance between runs","category":"section"},{"location":"advanced/convergence/#Lyapunov-Function","page":"Convergence Analysis","title":"Lyapunov Function","text":"Energy-like measure for convergence proofs.\n\n# Current state of all processes\nstates = [1.5, 2.3, 1.9, 2.1]\n\n# Compute Lyapunov function V(x) = Œ£(x·µ¢ - xÃÑ)¬≤\nV = lyapunov_function(states)\n\n# For convergence proofs, show V decreases over time\nstate_history = [states_at_round_0, states_at_round_1, ...]\nV_trajectory = lyapunov_function(state_history)\n\n# Should be monotonically decreasing\n\nUse case: Formal convergence proofs, theoretical analysis.","category":"section"},{"location":"advanced/convergence/#Mixing-Time","page":"Convergence Analysis","title":"Mixing Time","text":"Time until distribution is Œµ-close to stationary (consensus).\n\nstate_history = [\n    [1.0, 2.0, 3.0],  # Round 0\n    [1.5, 2.0, 2.5],  # Round 1\n    [1.8, 2.0, 2.2],  # Round 2\n    # ...\n]\n\nŒµ = 0.1\nt_mix = mixing_time(state_history, Œµ)\n\nprintln(\"Mixing time: $t_mix rounds\")","category":"section"},{"location":"advanced/convergence/#Diameter-Bound-Efficiency","page":"Convergence Analysis","title":"Diameter Bound Efficiency","text":"Compare actual convergence to theoretical bound.\n\nusing StochProtocol\n\n# Run on ring topology\nresults = run_protocol(protocol;\n    topology = Ring(),\n    p_values = [0.7],\n    rounds = 50,\n    n_processes = 20,\n    repetitions = 1000\n)\n\n# Get actual convergence time\nactual_rounds = time_to_epsilon_consensus(results[1].discrepancy_trace, 0.01)\n\n# Ring diameter\ntopo = Ring()\nd = diameter(topo, 20)  # d = 10 for ring with 20 nodes\n\np = 0.7\nefficiency = diameter_bound_efficiency(actual_rounds, d, p)\n\nprintln(\"Theoretical bound: $(d/p) rounds\")\nprintln(\"Actual: $actual_rounds rounds\")\nprintln(\"Efficiency ratio: $efficiency\")\n\nInterpretation:\n\nRatio < 1.0 = faster than theoretical bound (tight analysis)\nRatio ‚âà 1.0 = matches theory\nRatio > 1.0 = slower than expected","category":"section"},{"location":"advanced/convergence/#Tail-Bound-Analysis","page":"Convergence Analysis","title":"Tail Bound Analysis","text":"Confidence intervals for convergence time.\n\n# Collect convergence times from many runs\nconvergence_times = Int[]\n\nfor i in 1:1000\n    result = run_protocol(protocol; p=0.7, rounds=50, seed=UInt32(i))\n    t = time_to_epsilon_consensus(result.discrepancy_trace, 0.01)\n    if t > 0\n        push!(convergence_times, t)\n    end\nend\n\n# Compute 95% confidence interval\nmean_t, lower, upper = tail_bound_analysis(convergence_times; confidence=0.95)\n\nprintln(\"Mean convergence time: $mean_t rounds\")\nprintln(\"95% CI: [$lower, $upper]\")","category":"section"},{"location":"advanced/convergence/#Phase-Transition-Detection","page":"Convergence Analysis","title":"Phase Transition Detection","text":"Find critical p where convergence behavior changes dramatically.\n\np_values = 0.0:0.05:1.0\nconvergence_times = Float64[]\n\nfor p in p_values\n    result = run_protocol(protocol; p=p, rounds=100, repetitions=500)\n    avg_time = mean([time_to_epsilon_consensus(r.discrepancy_trace, 0.01)\n                     for r in result])\n    push!(convergence_times, avg_time)\nend\n\n# Find phase transition point\np_critical = phase_transition_detection(p_values, convergence_times)\n\nprintln(\"Phase transition at p ‚âà $p_critical\")\n\nUse case: Find minimum communication probability needed for efficient convergence.","category":"section"},{"location":"advanced/convergence/#Convergence-Probability","page":"Convergence Analysis","title":"Convergence Probability","text":"Estimate probability of reaching consensus within time limit.\n\n# Run many times\ntrajectories = [run_protocol(protocol; p=0.6, rounds=20, seed=UInt32(i)).discrepancy_trace\n                for i in 1:1000]\n\n# Probability of 0.01-consensus within 15 rounds\nprob = convergence_probability(trajectories, 0.01, 15)\n\nprintln(\"P(consensus by round 15) = $prob\")","category":"section"},{"location":"advanced/convergence/#Expected-Rounds-to-Consensus","page":"Convergence Analysis","title":"Expected Rounds to Consensus","text":"Summary statistics for convergence time distribution.\n\nconvergence_times = [time_to_epsilon_consensus(traj, 0.01) for traj in trajectories]\n\nmean_t, median_t, p90, p99 = expected_rounds_to_consensus(convergence_times)\n\nprintln(\"Mean: $mean_t rounds\")\nprintln(\"Median: $median_t rounds\")\nprintln(\"90th percentile: $p90 rounds\")\nprintln(\"99th percentile: $p99 rounds\")\n\nInterpretation:\n\nMean: Average case\nMedian: Typical case\n90th percentile: Most runs finish by this time\n99th percentile: Nearly all runs finish by this time","category":"section"},{"location":"advanced/convergence/#Spectral-Gap-Estimate","page":"Convergence Analysis","title":"Spectral Gap Estimate","text":"Estimate spectral gap from convergence rate.\n\nŒª = convergence_rate(discrepancies)\nd = diameter(topology, n_processes)\n\nspectral_gap = spectral_gap_estimate(Œª, d)\n\nprintln(\"Estimated spectral gap: $spectral_gap\")\n\nUse case: Connect empirical observations to theoretical graph properties.","category":"section"},{"location":"advanced/convergence/#Contraction-Factor","page":"Convergence Analysis","title":"Contraction Factor","text":"Single-round contraction of discrepancy.\n\nD_before = 10.0\nD_after = 7.5\n\nœÅ = contraction_factor(D_before, D_after)\n# œÅ = 0.75 means 25% reduction per round\n\nAverage over all rounds:\n\navg_œÅ = average_contraction(discrepancies)\n\nprintln(\"Average contraction factor: $avg_œÅ\")\nprintln(\"Per-round reduction: $(100*(1-avg_œÅ))%\")","category":"section"},{"location":"advanced/convergence/#Variance-Reduction-Rate","page":"Convergence Analysis","title":"Variance Reduction Rate","text":"How quickly variance across processes decreases.\n\nstate_history = [\n    [1.0, 5.0, 3.0, 2.0],  # Round 0\n    [2.0, 4.0, 3.0, 2.5],  # Round 1\n    [2.5, 3.5, 3.0, 2.8],  # Round 2\n    # ...\n]\n\nrate = variance_reduction_rate(state_history)\n\nprintln(\"Variance reduction rate: $rate\")","category":"section"},{"location":"advanced/convergence/#Complete-Example","page":"Convergence Analysis","title":"Complete Example","text":"Comprehensive convergence analysis:\n\nusing StochProtocol\n\nprotocol = Protocol(\"\"\"\nPROTOCOL TestProtocol\nPROCESSES: 10\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS:\n    discrepancy\n\"\"\")\n\n# Run experiments\nresults = run_protocol(protocol;\n    p_values = 0.5:0.1:1.0,\n    rounds = 50,\n    repetitions = 1000\n)\n\nprintln(\"=\"^60)\nprintln(\"Convergence Analysis Report\")\nprintln(\"=\"^60)\n\nfor (i, p) in enumerate(0.5:0.1:1.0)\n    println(\"\\nCommunication probability p = $p\")\n    println(\"-\"^40)\n\n    disc = results[i].discrepancy_trace\n\n    # Convergence rate\n    Œª = convergence_rate(disc)\n    println(\"Convergence rate Œª: $(round(Œª, digits=4))\")\n    println(\"Half-life: $(round(log(2)/Œª, digits=2)) rounds\")\n\n    # Time to consensus\n    t_001 = time_to_epsilon_consensus(disc, 0.01)\n    println(\"Time to 0.01-consensus: $t_001 rounds\")\n\n    # Contraction\n    œÅ = average_contraction(disc)\n    println(\"Average contraction: $(round(100*(1-œÅ), digits=1))% per round\")\nend\n\nprintln(\"\\n\" * \"=\"^60)","category":"section"},{"location":"advanced/convergence/#Best-Practices","page":"Convergence Analysis","title":"Best Practices","text":"Multiple metrics: Use several metrics for complete picture\nHigh repetitions: Statistical metrics need many samples (1000+)\nAppropriate Œµ: Choose epsilon based on application needs\nCompare scenarios: Analyze across different p, topologies, etc.\nTheoretical validation: Compare empirical results to known bounds","category":"section"},{"location":"guides/experiments/#Running-Experiments","page":"Running Experiments","title":"Running Experiments","text":"Complete guide to running simulations and analyzing results with StochProtocol\n\n","category":"section"},{"location":"guides/experiments/#Quick-Start","page":"Running Experiments","title":"Quick Start","text":"<div class=\"admonition is-info\">\n    <div class=\"admonition-header\">üéØ Main Function</div>\n    <p>The primary entry point for all experiments is <code>run_protocol</code>. It handles Monte Carlo simulation, statistical analysis, and result aggregation automatically.</p>\n</div>\n\nThe main function for running experiments is run_protocol:\n\nusing StochProtocol\n\nresults = run_protocol(my_protocol;\n    p_values = 0.0:0.1:1.0,\n    rounds = 1,\n    repetitions = 2000,\n    seed = 42\n)\n\n","category":"section"},{"location":"guides/experiments/#run_protocol-Function","page":"Running Experiments","title":"run_protocol Function","text":"","category":"section"},{"location":"guides/experiments/#Signature","page":"Running Experiments","title":"Signature","text":"run_protocol(protocol;\n    p_values = 0:0.05:1,\n    rounds::Int = 1,\n    repetitions::Int = 2000,\n    seed::Union{Int,Nothing} = nothing,\n    consensus_eps::Float64 = 1e-6,\n    debug::Bool = false,\n    trace::Bool = false,\n    trace_limit::Int = 1\n)","category":"section"},{"location":"guides/experiments/#Parameters","page":"Running Experiments","title":"Parameters","text":"Parameter Type Default Description\nprotocol Protocol or String - Protocol definition or file path\np_values Range or Vector 0:0.05:1 Delivery probabilities to test\nrounds Int 1 Number of communication rounds\nrepetitions Int 2000 Monte Carlo repetitions per p value\nseed Int or nothing nothing Random seed (auto if nothing)\nconsensus_eps Float64 1e-6 Consensus threshold (discrepancy ‚â§ Œµ)\ndebug Bool false Print debug information\ntrace Bool false Show detailed execution trace\ntrace_limit Int 1 Max repetitions to trace","category":"section"},{"location":"guides/experiments/#Return-Value","page":"Running Experiments","title":"Return Value","text":"Returns an ExploreRun object containing results for all p values.\n\n","category":"section"},{"location":"guides/experiments/#Configuring-Experiments","page":"Running Experiments","title":"Configuring Experiments","text":"","category":"section"},{"location":"guides/experiments/#Probability-Ranges","page":"Running Experiments","title":"Probability Ranges","text":"Test across different delivery probabilities:\n\n# Coarse sweep\nresults = run_protocol(proto; p_values=0.0:0.2:1.0)\n\n# Fine sweep\nresults = run_protocol(proto; p_values=0.0:0.01:1.0)\n\n# Specific values\nresults = run_protocol(proto; p_values=[0.5, 0.7, 0.9, 1.0])\n\n# High probability region\nresults = run_protocol(proto; p_values=0.8:0.02:1.0)","category":"section"},{"location":"guides/experiments/#Number-of-Rounds","page":"Running Experiments","title":"Number of Rounds","text":"Control how many communication rounds to simulate:\n\n# Single round\nresults = run_protocol(proto; rounds=1)\n\n# Multiple rounds to study convergence\nresults = run_protocol(proto; rounds=10)\n\n# Many rounds for slow protocols\nresults = run_protocol(proto; rounds=100)","category":"section"},{"location":"guides/experiments/#Repetitions","page":"Running Experiments","title":"Repetitions","text":"More repetitions = better statistics but longer runtime:\n\n# Quick test\nresults = run_protocol(proto; repetitions=100)\n\n# Standard analysis\nresults = run_protocol(proto; repetitions=2000)\n\n# High-precision analysis\nresults = run_protocol(proto; repetitions=10000)\n\n<div class=\"admonition is-success\">\n    <div class=\"admonition-header\">üìä Repetition Guidelines</div>\n    <ul style=\"margin: 0.5rem 0;\">\n        <li><strong>100-500</strong>: Quick testing during development</li>\n        <li><strong>1000-2000</strong>: Standard analysis for most use cases</li>\n        <li><strong>5000+</strong>: Publication-quality, high-precision results</li>\n    </ul>\n</div>","category":"section"},{"location":"guides/experiments/#Random-Seeds","page":"Running Experiments","title":"Random Seeds","text":"Control reproducibility:\n\n# Reproducible (same results every time)\nresults = run_protocol(proto; seed=42)\n\n# Different seed\nresults = run_protocol(proto; seed=123)\n\n# Random (different each run)\nresults = run_protocol(proto; seed=nothing)  # default","category":"section"},{"location":"guides/experiments/#Consensus-Threshold","page":"Running Experiments","title":"Consensus Threshold","text":"Adjust what counts as consensus:\n\n# Strict consensus (default)\nresults = run_protocol(proto; consensus_eps=1e-6)\n\n# Looser consensus\nresults = run_protocol(proto; consensus_eps=1e-3)\n\n# Very loose (for noisy protocols)\nresults = run_protocol(proto; consensus_eps=0.01)\n\n","category":"section"},{"location":"guides/experiments/#Working-with-Results","page":"Running Experiments","title":"Working with Results","text":"","category":"section"},{"location":"guides/experiments/#Viewing-Results","page":"Running Experiments","title":"Viewing Results","text":"# Beautiful table in Jupyter\nresults_table(results)\n\n# With custom protocol name\nresults_table(results; protocol_name=\"My Protocol\")\n\n# Summary statistics\nsummary(results)\n\n# Raw data access\nfor result in results\n    println(\"p=$(result.p): E[D]=$(result.mean_discrepancy)\")\nend","category":"section"},{"location":"guides/experiments/#Extracting-Data","page":"Running Experiments","title":"Extracting Data","text":"# Get all p values tested\np_vals = [r.p for r in results]\n\n# Get expected discrepancies\nE_D = [r.mean_discrepancy for r in results]\n\n# Get consensus probabilities\nP_consensus = [r.consensus_probability for r in results]\n\n# Get number of repetitions (useful for guaranteed models)\nreps = [r.repetitions for r in results]\n\n","category":"section"},{"location":"guides/experiments/#Visualization","page":"Running Experiments","title":"Visualization","text":"","category":"section"},{"location":"guides/experiments/#Discrepancy-vs-Probability","page":"Running Experiments","title":"Discrepancy vs Probability","text":"using StochProtocol\n\nplot_discrepancy_vs_p(results;\n    title = \"Protocol Performance\",\n    xlabel = \"Delivery Probability p\",\n    ylabel = \"Expected Discrepancy E[D]\",\n    save_path = \"results.png\"  # Optional: save to file\n)\n\nOptions:\n\ntitle: Plot title\nxlabel, ylabel: Axis labels\nsave_path: Save to file (PNG, PDF, SVG)\nsize: Plot dimensions (default: (800, 600))\ndpi: Resolution (default: 300)","category":"section"},{"location":"guides/experiments/#Consensus-vs-Probability","page":"Running Experiments","title":"Consensus vs Probability","text":"plot_consensus_vs_p(results;\n    title = \"Consensus Probability\",\n    save_path = \"consensus.png\"\n)","category":"section"},{"location":"guides/experiments/#Comparing-Multiple-Protocols","page":"Running Experiments","title":"Comparing Multiple Protocols","text":"results_amp = run_protocol(amp; p_values=0.0:0.1:1.0)\nresults_fv = run_protocol(fv; p_values=0.0:0.1:1.0)\n\nplot_comparison([\n    (\"AMP\", results_amp),\n    (\"FV\", results_fv)\n];\n    title = \"Protocol Comparison\",\n    save_path = \"comparison.png\"\n)\n\n","category":"section"},{"location":"guides/experiments/#Advanced-Usage","page":"Running Experiments","title":"Advanced Usage","text":"","category":"section"},{"location":"guides/experiments/#Debugging","page":"Running Experiments","title":"Debugging","text":"Enable debug mode to see what's happening:\n\nresults = run_protocol(proto;\n    p_values = [0.5],\n    repetitions = 10,\n    debug = true\n)","category":"section"},{"location":"guides/experiments/#Execution-Traces","page":"Running Experiments","title":"Execution Traces","text":"See detailed round-by-round execution:\n\nresults = run_protocol(proto;\n    p_values = [0.7],\n    repetitions = 5,\n    trace = true,\n    trace_limit = 2  # Only trace first 2 repetitions\n)\n\nOutput shows:\n\nState before each round\nMessages received\nState after update\nDiscrepancy and consensus status","category":"section"},{"location":"guides/experiments/#Parameter-Sweeps","page":"Running Experiments","title":"Parameter Sweeps","text":"Explore protocol behavior across parameter spaces:\n\nusing StochProtocol\n\nfunction make_amp(y_val)\n    return Protocol(\"\"\"\n    PROTOCOL AMP_y$y_val\n    PROCESSES: 2\n    STATE: x ‚àà {0,1}\n    INITIAL VALUES: [0.0, 1.0]\n    PARAMETERS: y = $y_val\n    CHANNEL: stochastic\n    UPDATE RULE:\n        EACH ROUND:\n            if received_diff then x·µ¢ ‚Üê y else x·µ¢ ‚Üê x end\n    METRICS: discrepancy, consensus\n    \"\"\")\nend\n\nfor y in 0.0:0.1:1.0\n    proto = make_amp(y)\n    results = run_protocol(proto; p_values=0.5:0.1:1.0, repetitions=1000)\n    println(\"y=$y, E[D] at p=0.8: $(results[7].mean_discrepancy)\")\nend","category":"section"},{"location":"guides/experiments/#Batch-Analysis","page":"Running Experiments","title":"Batch Analysis","text":"Run multiple experiments efficiently:\n\nprotocols = [\n    (\"AMP\", amp_protocol),\n    (\"FV\", fv_protocol),\n    (\"MIN\", min_protocol)\n]\n\nall_results = []\n\nfor (name, proto) in protocols\n    println(\"Running $name...\")\n    results = run_protocol(proto;\n        p_values = 0.0:0.05:1.0,\n        repetitions = 2000,\n        seed = 42\n    )\n    push!(all_results, (name, results))\n\n    # Save individual results\n    plot_discrepancy_vs_p(results;\n        title = \"$name Protocol\",\n        save_path = \"$(name)_results.png\"\n    )\nend\n\n# Compare all\nresults_comparison_table(all_results)\n\n","category":"section"},{"location":"guides/experiments/#Performance-Tips","page":"Running Experiments","title":"Performance Tips","text":"","category":"section"},{"location":"guides/experiments/#Optimize-Repetitions","page":"Running Experiments","title":"Optimize Repetitions","text":"# Start with fewer repetitions during development\ndev_results = run_protocol(proto; p_values=0.0:0.2:1.0, repetitions=100)\n\n# Scale up for final analysis\nfinal_results = run_protocol(proto; p_values=0.0:0.05:1.0, repetitions=5000)","category":"section"},{"location":"guides/experiments/#Reduce-p-value-Granularity","page":"Running Experiments","title":"Reduce p-value Granularity","text":"# Coarse first\nquick = run_protocol(proto; p_values=0.0:0.1:1.0, repetitions=500)\n\n# Then zoom into interesting regions\ndetailed = run_protocol(proto; p_values=0.7:0.01:0.9, repetitions=2000)","category":"section"},{"location":"guides/experiments/#Guaranteed-Models","page":"Running Experiments","title":"Guaranteed Models","text":"For guaranteed delivery models, you may need more attempts:\n\n# Standard model: 2000 repetitions = 2000 valid runs\n# Guaranteed model at low p: may need 100x attempts to get 2000 valid runs\n\nresults = run_protocol(guaranteed_proto;\n    p_values = 0.3:0.1:1.0,  # Start from higher p\n    repetitions = 1000        # May get fewer than 1000 at low p\n)\n\n","category":"section"},{"location":"guides/experiments/#Common-Patterns","page":"Running Experiments","title":"Common Patterns","text":"","category":"section"},{"location":"guides/experiments/#Quick-Test","page":"Running Experiments","title":"Quick Test","text":"# Fast test during development\ntest = run_protocol(my_proto;\n    p_values = [0.5, 0.9],\n    repetitions = 100,\n    seed = 42\n)","category":"section"},{"location":"guides/experiments/#Publication-Analysis","page":"Running Experiments","title":"Publication Analysis","text":"# High-quality results for papers\nfinal = run_protocol(my_proto;\n    p_values = 0.0:0.02:1.0,\n    repetitions = 5000,\n    seed = 42\n)\n\nplot_discrepancy_vs_p(final;\n    title = \"Protocol Performance\",\n    save_path = \"figure1.pdf\",\n    dpi = 300\n)","category":"section"},{"location":"guides/experiments/#Convergence-Study","page":"Running Experiments","title":"Convergence Study","text":"# Study how many rounds needed\nfor rounds in [1, 5, 10, 20, 50]\n    results = run_protocol(proto;\n        rounds = rounds,\n        p_values = 0.7:0.1:1.0,\n        repetitions = 1000\n    )\n    println(\"Rounds=$rounds, E[D] at p=0.9: $(results[3].mean_discrepancy)\")\nend\n\n","category":"section"},{"location":"guides/experiments/#See-Also","page":"Running Experiments","title":"See Also","text":"Protocol DSL - Define protocols\nDelivery Models - Communication models\nVisualization Guide - Plotting and tables\nAPI Reference - Function details","category":"section"},{"location":"guides/delivery_models/#Delivery-Models-in-StochProtocol","page":"Delivery Models","title":"Delivery Models in StochProtocol","text":"Flexible communication models for realistic network simulation\n\n\n\nStochProtocol supports multiple communication delivery models that allow you to experiment with different network conditions and message delivery guarantees.","category":"section"},{"location":"guides/delivery_models/#Overview","page":"Delivery Models","title":"Overview","text":"<div class=\"admonition is-info\">\n    <div class=\"admonition-header\">üéØ Why Delivery Models Matter</div>\n    <p>Different delivery models capture different assumptions about network behavior: simple probabilistic channels, guaranteed delivery semantics, broadcast primitives, or complex hybrid scenarios. Choose the model that matches your research question.</p>\n</div>\n\nDelivery models control how messages are delivered between processes in your protocol:\n\nGlobal models: Apply the same model to all processes\nProcess-specific models: Different processes can use different delivery models\nHybrid configurations: Mix and match models for heterogeneous networks","category":"section"},{"location":"guides/delivery_models/#Available-Models","page":"Delivery Models","title":"Available Models","text":"","category":"section"},{"location":"guides/delivery_models/#1.-Standard-Model-(Default)","page":"Delivery Models","title":"1. Standard Model (Default)","text":"Classic probabilistic delivery where each message is delivered independently with probability p.\n\nSyntax:\n\nMODEL:\n    standard\n\nCharacteristics:\n\nEach message has independent probability p of delivery\nDefault behavior if no MODEL section specified\nBest for simulating typical unreliable networks\n\nExample:\n\nprotocol\"\"\"\nPROTOCOL MyProtocol\n...\nMODEL:\n    standard\n...\n\"\"\"","category":"section"},{"location":"guides/delivery_models/#2.-Guaranteed-Model","page":"Delivery Models","title":"2. Guaranteed Model","text":"Ensures a minimum number of messages are delivered, either per round or across the entire execution.\n\nSyntax:\n\nMODEL:\n    guaranteed k=<number> scope=<per_round|total>\n\nParameters:\n\nk: Minimum number of messages that must be delivered\nscope:\nper_round: Guarantee applies to each round individually\ntotal: Guarantee applies to total messages across all rounds\n\nCharacteristics:\n\nRuns that don't meet the guarantee are filtered out (not counted in statistics)\nMay reduce the number of valid repetitions for low p values\nUseful for modeling networks with minimum reliability requirements\n\nExample:\n\nprotocol\"\"\"\nPROTOCOL ReliableProtocol\nPROCESSES: 4\n...\nMODEL:\n    guaranteed k=3 scope=per_round\n...\n\"\"\"\n\nThis ensures at least 3 messages are delivered in every round. Runs with fewer messages are discarded.","category":"section"},{"location":"guides/delivery_models/#3.-Broadcast-Model","page":"Delivery Models","title":"3. Broadcast Model","text":"All-or-nothing delivery per source process. If any message from a process is delivered, all its messages are delivered.\n\nSyntax:\n\nMODEL:\n    broadcast probability=<per_source|uniform>\n\nParameters:\n\nprobability:\nper_source: Each source independently decides to broadcast with probability p\nuniform: Global probability p for all sources\n\nCharacteristics:\n\nCorrelated delivery: all messages from a source succeed/fail together\nModels broadcast primitives or atomic multicast\nUseful for protocols that rely on complete information from sources\n\nExample:\n\nprotocol\"\"\"\nPROTOCOL BroadcastProtocol\nPROCESSES: 3\n...\nMODEL:\n    broadcast probability=per_source\n...\n\"\"\"","category":"section"},{"location":"guides/delivery_models/#Process-Specific-Models","page":"Delivery Models","title":"Process-Specific Models","text":"You can assign different models to different processes for heterogeneous networks.\n\nSyntax:\n\nMODEL:\n    process <id>: <model_spec>\n    process <id>: <model_spec>\n    ...\n\nExample:\n\nprotocol\"\"\"\nPROTOCOL HybridProtocol\nPROCESSES: 4\n...\nMODEL:\n    process 1: standard\n    process 2: broadcast\n    process 3: broadcast\n    process 4: guaranteed k=2 scope=per_round\n...\n\"\"\"\n\nIn this configuration:\n\nProcess 1 uses independent delivery\nProcesses 2 & 3 use broadcast (all-or-nothing)\nProcess 4 guarantees at least 2 messages per round","category":"section"},{"location":"guides/delivery_models/#Complete-Examples","page":"Delivery Models","title":"Complete Examples","text":"","category":"section"},{"location":"guides/delivery_models/#Example-1:-Comparing-Models-on-AMP-Protocol","page":"Delivery Models","title":"Example 1: Comparing Models on AMP Protocol","text":"using StochProtocol\n\n# Standard model\namp_standard = Protocol(\"\"\"\nPROTOCOL AMP_Standard\nPROCESSES: 3\nSTATE: x ‚àà {0,1}\nINITIAL VALUES: [0.0, 0.5, 1.0]\nPARAMETERS: y ‚àà [0,1] = 0.5\nCHANNEL: stochastic\nMODEL: standard\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then x·µ¢ ‚Üê y else x·µ¢ ‚Üê x end\nMETRICS: discrepancy, consensus\n\"\"\")\n\n# Guaranteed model\namp_guaranteed = Protocol(\"\"\"\nPROTOCOL AMP_Guaranteed\nPROCESSES: 3\nSTATE: x ‚àà {0,1}\nINITIAL VALUES: [0.0, 0.5, 1.0]\nPARAMETERS: y ‚àà [0,1] = 0.5\nCHANNEL: stochastic\nMODEL: guaranteed k=2 scope=per_round\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then x·µ¢ ‚Üê y else x·µ¢ ‚Üê x end\nMETRICS: discrepancy, consensus\n\"\"\")\n\n# Run and compare\nresults_std = run_protocol(amp_standard; p_values=0.0:0.1:1.0, repetitions=2000)\nresults_gua = run_protocol(amp_guaranteed; p_values=0.0:0.1:1.0, repetitions=2000)\n\nplot_comparison([(\"Standard\", results_std), (\"Guaranteed k=2\", results_gua)])","category":"section"},{"location":"guides/delivery_models/#Example-2:-Hybrid-Network-Simulation","page":"Delivery Models","title":"Example 2: Hybrid Network Simulation","text":"# Simulate a network where some nodes have better connectivity\nheterogeneous = Protocol(\"\"\"\nPROTOCOL HeterogeneousAveraging\nPROCESSES: 6\nSTATE: x ‚àà ‚Ñù\nINITIAL VALUES: [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\nCHANNEL: stochastic\n\nMODEL:\n    process 1: standard\n    process 2: standard\n    process 3: broadcast\n    process 4: broadcast\n    process 5: guaranteed k=4 scope=per_round\n    process 6: guaranteed k=4 scope=per_round\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\nresults = run_protocol(heterogeneous; p_values=[0.5, 0.7, 0.9], repetitions=1000)\nresults_table(results)","category":"section"},{"location":"guides/delivery_models/#Implementation-Details","page":"Delivery Models","title":"Implementation Details","text":"","category":"section"},{"location":"guides/delivery_models/#How-Guaranteed-Models-Work","page":"Delivery Models","title":"How Guaranteed Models Work","text":"When using a guaranteed model with scope=per_round:\n\nProtocol runs normally\nAfter each round, delivered messages are counted\nIf count < k, the entire run is discarded\nOnly runs that satisfy the guarantee contribute to statistics\n\nThis means:\n\nAt low p values, you may get far fewer than requested repetitions\nStochProtocol will attempt up to 100√ó the requested repetitions\nA warning is issued if insufficient valid runs are found","category":"section"},{"location":"guides/delivery_models/#Performance-Considerations","page":"Delivery Models","title":"Performance Considerations","text":"Standard: Fastest, no filtering needed\nBroadcast: Slightly faster than standard (fewer random numbers generated)\nGuaranteed: Slowest for low p (many runs discarded)\n\nFor guaranteed models with strict constraints and low p, consider:\n\nIncreasing repetitions budget\nUsing less strict guarantees\nFocusing analysis on higher p values","category":"section"},{"location":"guides/delivery_models/#Use-Cases","page":"Delivery Models","title":"Use Cases","text":"Model Best For\nStandard General-purpose, typical unreliable networks\nGuaranteed Modeling QoS guarantees, studying minimum connectivity requirements\nBroadcast Atomic broadcast primitives, correlated failures, gossip protocols\nHybrid Heterogeneous networks, partial broadcast, tiered architectures","category":"section"},{"location":"guides/delivery_models/#Advanced:-Model-Configuration-in-Code","page":"Delivery Models","title":"Advanced: Model Configuration in Code","text":"You can also inspect and modify delivery models programmatically (for advanced use cases):\n\n# Models are parsed from the protocol definition\n# and stored in the ProtocolIR structure\nusing StochProtocol.DSL.IR: DeliveryModelSpec\n\n# Example: programmatically create a model spec\nspec = DeliveryModelSpec(\n    :guaranteed,  # model type\n    Dict(:min_messages => 3, :scope => :per_round),  # parameters\n    nothing  # process_id (nothing = global)\n)","category":"section"},{"location":"guides/delivery_models/#See-Also","page":"Delivery Models","title":"See Also","text":"Protocol DSL Reference\nExperiments Guide\nExamples","category":"section"},{"location":"api/core/#Core-Functions","page":"Core Functions","title":"Core Functions","text":"Core API for defining and running protocols.","category":"section"},{"location":"api/core/#Protocol-Definition","page":"Core Functions","title":"Protocol Definition","text":"","category":"section"},{"location":"api/core/#Usage","page":"Core Functions","title":"Usage","text":"using StochProtocol\n\n# Define a protocol\nAMP = Protocol(\"\"\"\nPROTOCOL AMP\nPROCESSES: 2\n...\n\"\"\")\n\nThe Protocol wrapper provides beautiful display in notebooks and REPL.","category":"section"},{"location":"api/core/#Running-Experiments","page":"Core Functions","title":"Running Experiments","text":"","category":"section"},{"location":"api/core/#Examples","page":"Core Functions","title":"Examples","text":"Basic usage:\n\nresults = run_protocol(AMP; p_values=0.0:0.1:1.0)\n\nWith all parameters:\n\nresults = run_protocol(AMP;\n                       p_values=[0.2, 0.5, 0.8],  # Custom probabilities\n                       rounds=3,                    # Multiple rounds\n                       repetitions=5000,            # High accuracy\n                       seed=42,                     # Reproducible\n                       consensus_eps=1e-6)          # Consensus threshold\n\nFrom file:\n\nresults = run_protocol(\"protocols/amp.txt\";\n                       p_values=0.0:0.05:1.0)","category":"section"},{"location":"api/core/#Results","page":"Core Functions","title":"Results","text":"","category":"section"},{"location":"api/core/#ExploreRun","page":"Core Functions","title":"ExploreRun","text":"Results are returned as an ExploreRun object:\n\nresults = run_protocol(...)\n\n# Access properties\nresults.name           # Protocol name\nresults.num_processes  # Number of processes\nresults.rounds         # Number of rounds\nresults.repetitions    # Monte Carlo samples\nresults.p_values       # Probabilities tested\nresults.results        # Individual MonteCarloResult objects\n\n# Iterate over results\nfor r in results\n    println(\"p=$(r.p), E[D]=$(r.mean_discrepancy)\")\nend\n\n# Index access\nfirst_result = results[1]","category":"section"},{"location":"api/core/#MonteCarloResult","page":"Core Functions","title":"MonteCarloResult","text":"Each p-value has a MonteCarloResult:\n\nr = results[1]\n\nr.p                      # Delivery probability\nr.repetitions            # Number of trials\nr.mean_discrepancy       # E[D]\nr.var_discrepancy        # Var[D]\nr.consensus_probability  # P(consensus)\nr.mean_discrepancy_by_round  # Round-by-round E[D]","category":"section"},{"location":"api/core/#Utility-Functions","page":"Core Functions","title":"Utility Functions","text":"","category":"section"},{"location":"api/core/#Usage-2","page":"Core Functions","title":"Usage","text":"# Text summary\nsummary(results)\n\n# Tabular data\ndf = table(results)  # Returns DataFrame if available","category":"section"},{"location":"api/core/#Parameters","page":"Core Functions","title":"Parameters","text":"","category":"section"},{"location":"api/core/#p_values","page":"Core Functions","title":"p_values","text":"Message delivery probability. Accepts:\n\nRange: 0.0:0.1:1.0\nList: [0.2, 0.5, 0.8]\nSingle value: 0.5 (converted to [0.5])","category":"section"},{"location":"api/core/#rounds","page":"Core Functions","title":"rounds","text":"Number of communication rounds. Default: 1\n\n# Single round\nresults = run_protocol(AMP; rounds=1)\n\n# Analyze convergence over multiple rounds\nresults = run_protocol(AMP; rounds=10)","category":"section"},{"location":"api/core/#repetitions","page":"Core Functions","title":"repetitions","text":"Monte Carlo samples per p-value. Default: 2000\n\n500-1000: Fast prototyping\n2000-5000: Standard analysis\n10000+: High-precision results","category":"section"},{"location":"api/core/#seed","page":"Core Functions","title":"seed","text":"Random seed for reproducibility. Default: nothing (random)\n\n# Reproducible results\nresults1 = run_protocol(AMP; seed=42)\nresults2 = run_protocol(AMP; seed=42)\n# results1 == results2  ‚úì\n\n# Random (different each time)\nresults = run_protocol(AMP)","category":"section"},{"location":"api/core/#consensus_eps","page":"Core Functions","title":"consensus_eps","text":"Threshold for consensus detection. Default: 1e-10\n\nTwo processes are in consensus if |x‚ÇÅ - x‚ÇÇ| ‚â§ consensus_eps.\n\n# Stricter consensus\nresults = run_protocol(AMP; consensus_eps=1e-12)\n\n# Looser consensus\nresults = run_protocol(AMP; consensus_eps=1e-6)","category":"section"},{"location":"api/core/#See-Also","page":"Core Functions","title":"See Also","text":"Protocol DSL - Protocol specification language\nVisualization - Plotting and tables\nExamples - Complete examples","category":"section"},{"location":"api/core/#StochProtocol.ProtocolString.Protocol","page":"Core Functions","title":"StochProtocol.ProtocolString.Protocol","text":"Protocol(text::String)\n\nWrapper para strings de protocolos que se muestra bonito en notebooks.\n\nEjemplo\n\nAMP = Protocol(\"\"\"\nPROTOCOL AMP\nPROCESSES: 2\n...\n\"\"\")\n\n\n\n\n\n","category":"type"},{"location":"api/core/#StochProtocol.Explore.Run.run_protocol","page":"Core Functions","title":"StochProtocol.Explore.Run.run_protocol","text":"Explicit API to run a protocol specified by path or inline DSL text. Accepts either an existing file, raw DSL text, a Protocol object, or an ExploreRun (returned as-is).\n\n\n\n\n\n","category":"function"},{"location":"api/core/#StochProtocol.Explore.Views.table","page":"Core Functions","title":"StochProtocol.Explore.Views.table","text":"Return a table-like structure for a protocol run. DataFrame if available, otherwise a vector of NamedTuples.\n\n\n\n\n\n","category":"function"},{"location":"advanced/faults/#Fault-Models","page":"Fault Models","title":"Fault Models","text":"Test protocol robustness under failures and adversarial conditions.","category":"section"},{"location":"advanced/faults/#Overview","page":"Fault Models","title":"Overview","text":"Real distributed systems face failures: processes crash, messages get corrupted, networks partition, and malicious actors may exist. The Faults module lets you simulate these scenarios to test protocol resilience.","category":"section"},{"location":"advanced/faults/#Available-Fault-Models","page":"Fault Models","title":"Available Fault Models","text":"","category":"section"},{"location":"advanced/faults/#NoFaults-(Default)","page":"Fault Models","title":"NoFaults (Default)","text":"using StochProtocol\n\n# No faults - all processes behave correctly\nresults = run_protocol(protocol;\n    fault_model = NoFaults()\n)","category":"section"},{"location":"advanced/faults/#CrashFaults","page":"Fault Models","title":"CrashFaults","text":"Processes crash and stop sending messages permanently.\n\n# 30% of processes crash at round 5\nresults = run_protocol(protocol;\n    fault_model = CrashFaults(\n        crash_prob = 0.3,\n        crash_round = 5\n    ),\n    rounds = 20,\n    repetitions = 1000\n)\n\nParameters:\n\ncrash_prob: Probability each process crashes (0.0 to 1.0)\ncrash_round: Round at which crashes occur\nseed: Random seed for reproducibility\n\nUse case: Server failures, node crashes, power outages.","category":"section"},{"location":"advanced/faults/#ByzantineFaults","page":"Fault Models","title":"ByzantineFaults","text":"Malicious processes that send incorrect or adversarial values.\n\n# Processes 1 and 2 are Byzantine\nresults = run_protocol(protocol;\n    fault_model = ByzantineFaults(\n        byzantine_nodes = [1, 2],\n        strategy = :max_value\n    ),\n    rounds = 20\n)\n\nStrategies:\n\n:max_value - Always send maximum possible value\n:min_value - Always send minimum possible value\n:random - Send random values\n:opposite - Send negated values\n:silent - Don't send any messages\n:lie_to_half - Send correct to half, lies to other half\n\nUse case: Security attacks, malicious nodes, Byzantine consensus.","category":"section"},{"location":"advanced/faults/#NetworkPartition","page":"Fault Models","title":"NetworkPartition","text":"Network splits into disconnected groups.\n\n# Split network at round 5 for 3 rounds\nresults = run_protocol(protocol;\n    fault_model = NetworkPartition(\n        partition_round = 5,\n        partition_duration = 3,\n        groups = [[1,2,3], [4,5,6]]\n    ),\n    rounds = 20\n)\n\nParameters:\n\npartition_round: When partition begins\npartition_duration: How many rounds it lasts (0 = permanent)\ngroups: Vector of node groups (processes in different groups can't communicate)\n\nUse case: Network failures, data center outages, split-brain scenarios.","category":"section"},{"location":"advanced/faults/#MessageCorruption","page":"Fault Models","title":"MessageCorruption","text":"Messages get corrupted with given probability.\n\n# 10% of messages get corrupted\nresults = run_protocol(protocol;\n    fault_model = MessageCorruption(\n        corruption_prob = 0.1,\n        corruption_type = :random\n    ),\n    rounds = 20\n)\n\nCorruption types:\n\n:random - Replace with random value\n:zero - Replace with zero\n:max - Replace with very large value\n:flip_bits - Flip bits (for binary values)\n\nUse case: Noisy channels, bit errors, data corruption.","category":"section"},{"location":"advanced/faults/#DelayFaults","page":"Fault Models","title":"DelayFaults","text":"Messages delayed by multiple rounds.\n\n# 20% of messages delayed up to 3 rounds\nresults = run_protocol(protocol;\n    fault_model = DelayFaults(\n        delay_prob = 0.2,\n        max_delay = 3\n    ),\n    rounds = 30\n)\n\nUse case: High latency networks, congestion, buffering.","category":"section"},{"location":"advanced/faults/#TransientFaults","page":"Fault Models","title":"TransientFaults","text":"Random faults occurring during a time window.\n\n# Transient faults between rounds 5-15\nresults = run_protocol(protocol;\n    fault_model = TransientFaults(\n        fault_prob = 0.05,\n        start_round = 5,\n        end_round = 15,\n        fault_type = :send_wrong\n    ),\n    rounds = 30\n)\n\nFault types:\n\n:send_wrong - Send incorrect value\n:skip_update - Don't update state\n:corrupt_state - Corrupt internal state\n\nUse case: Temporary glitches, intermittent failures.","category":"section"},{"location":"advanced/faults/#CompositeFaults","page":"Fault Models","title":"CompositeFaults","text":"Combine multiple fault models.\n\n# Multiple faults simultaneously\nresults = run_protocol(protocol;\n    fault_model = CompositeFaults([\n        CrashFaults(crash_prob=0.1, crash_round=5),\n        MessageCorruption(corruption_prob=0.05),\n        NetworkPartition(\n            partition_round=10,\n            partition_duration=2,\n            groups=[[1,2,3], [4,5,6]]\n        )\n    ]),\n    rounds = 30\n)\n\nUse case: Realistic scenarios with multiple failure types.","category":"section"},{"location":"advanced/faults/#Example:-Byzantine-Tolerance","page":"Fault Models","title":"Example: Byzantine Tolerance","text":"Test if a protocol can tolerate Byzantine faults:\n\nusing StochProtocol\n\nprotocol = Protocol(\"\"\"\nPROTOCOL ByzantineRobustProtocol\nPROCESSES: 7\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        # Use median instead of average for Byzantine tolerance\n        x·µ¢ ‚Üê median(inbox_with_self)\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\n# Test with 2 Byzantine nodes (< n/3)\nresults = run_protocol(protocol;\n    fault_model = ByzantineFaults(\n        byzantine_nodes = [1, 2],\n        strategy = :max_value\n    ),\n    p_values = [1.0],\n    rounds = 20,\n    repetitions = 500\n)\n\nresults_table(results)\n\n# Compare: can tolerate f < n/3 Byzantine nodes\n# 7 processes ‚Üí can tolerate 2 Byzantine nodes\n# If 3+ are Byzantine, consensus may fail","category":"section"},{"location":"advanced/faults/#Example:-Network-Resilience","page":"Fault Models","title":"Example: Network Resilience","text":"Test recovery from network partition:\n\n# Temporary partition then recovery\nresults = run_protocol(protocol;\n    fault_model = NetworkPartition(\n        partition_round = 5,\n        partition_duration = 5,  # Partition for 5 rounds\n        groups = [[1,2,3,4], [5,6,7,8]]\n    ),\n    rounds = 30,\n    repetitions = 1000\n)\n\n# Analyze: does protocol recover after partition heals?\nplot_discrepancy_vs_p(results)","category":"section"},{"location":"advanced/faults/#Fault-Checking-Functions","page":"Fault Models","title":"Fault Checking Functions","text":"","category":"section"},{"location":"advanced/faults/#Check-if-Node-is-Faulty","page":"Fault Models","title":"Check if Node is Faulty","text":"fault_model = CrashFaults(crash_prob=0.3, crash_round=5)\n\n# Is process 2 faulty at round 10?\nis_faulty(fault_model, 2, 10)","category":"section"},{"location":"advanced/faults/#Get-Crashed-Nodes","page":"Fault Models","title":"Get Crashed Nodes","text":"# Which nodes crashed?\ncrashed = crashed_nodes(fault_model, 10)  # 10 total processes","category":"section"},{"location":"advanced/faults/#Best-Practices","page":"Fault Models","title":"Best Practices","text":"Start Simple: Test with NoFaults first, then add faults\nByzantine Tolerance: Use median/voting instead of average with Byzantine faults\nNetwork Partitions: Test both during partition and after recovery\nRealistic Scenarios: Use CompositeFaults for real-world modeling\nHigh Repetitions: Faults add randomness - use more repetitions (1000+)","category":"section"},{"location":"advanced/faults/#Theoretical-Bounds","page":"Fault Models","title":"Theoretical Bounds","text":"Common fault tolerance results:\n\nCrash failures: Can tolerate up to f < n crashes with 2f+1 processes\nByzantine failures: Requires n ‚â• 3f+1 for consensus\nPartitions: Need majority quorum (> n/2) to make progress","category":"section"},{"location":"examples/overview/#Examples","page":"Overview","title":"Examples","text":"Real-world protocols and use cases to get you started\n\n<div class=\"admonition is-success\">\n    <div class=\"admonition-header\">üí° Learning Path</div>\n    <p>Start with the <strong>Hello World</strong> example to understand the basics, then explore <strong>Classic Protocols</strong> for common patterns, and finally dive into <strong>Advanced Examples</strong> for research-grade implementations.</p>\n</div>\n\n","category":"section"},{"location":"examples/overview/#Getting-Started-Examples","page":"Overview","title":"Getting Started Examples","text":"","category":"section"},{"location":"examples/overview/#Hello-World:-AMP-Protocol","page":"Overview","title":"Hello World: AMP Protocol","text":"The simplest meaningful protocol - averaging with meeting point.\n\nusing StochProtocol\n\nAMP = Protocol(\"\"\"\nPROTOCOL AMP\nPROCESSES: 2\nSTATE: x ‚àà {0,1}\nINITIAL VALUES: [0.0, 1.0]\nPARAMETERS: y = 0.5\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then x·µ¢ ‚Üê y else x·µ¢ ‚Üê x end\n\nMETRICS: discrepancy, consensus\n\"\"\")\n\nresults = run_protocol(AMP; p_values=0.0:0.1:1.0, repetitions=2000)\nresults_table(results)\nplot_discrepancy_vs_p(results)\n\nTakeaway: When processes disagree, they move to meeting point y=0.5.\n\n","category":"section"},{"location":"examples/overview/#Classic-Protocols","page":"Overview","title":"Classic Protocols","text":"","category":"section"},{"location":"examples/overview/#Simple-Averaging","page":"Overview","title":"Simple Averaging","text":"Processes average their values with received messages.\n\naveraging = Protocol(\"\"\"\nPROTOCOL Averaging\nPROCESSES: 10\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS: discrepancy, consensus\n\"\"\")\n\nresults = run_protocol(averaging; rounds=10, p_values=0.5:0.1:1.0)\n\nUse Case: Study convergence rates under different communication probabilities.\n\n","category":"section"},{"location":"examples/overview/#Minimum-Protocol","page":"Overview","title":"Minimum Protocol","text":"Processes converge to the minimum value.\n\nminimum = Protocol(\"\"\"\nPROTOCOL Minimum\nPROCESSES: 5\nSTATE: x ‚àà ‚Ñù\nINITIAL VALUES: [5.0, 3.0, 8.0, 1.0, 6.0]\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_any then\n            x·µ¢ ‚Üê min(inbox_with_self)\n        else\n            x·µ¢ ‚Üê x\n        end\n\nMETRICS: discrepancy, consensus\n\"\"\")\n\nInsight: Minimum spreads through network, but requires at least one message delivery.\n\n","category":"section"},{"location":"examples/overview/#Delivery-Model-Examples","page":"Overview","title":"Delivery Model Examples","text":"","category":"section"},{"location":"examples/overview/#Guaranteed-Delivery","page":"Overview","title":"Guaranteed Delivery","text":"Ensure minimum connectivity requirements.\n\nguaranteed = Protocol(\"\"\"\nPROTOCOL GuaranteedAMP\nPROCESSES: 3\nSTATE: x ‚àà {0,1}\nINITIAL VALUES: [0.0, 0.5, 1.0]\nPARAMETERS: y = 0.5\nCHANNEL: stochastic\n\nMODEL:\n    guaranteed k=2 scope=per_round\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then x·µ¢ ‚Üê y else x·µ¢ ‚Üê x end\n\nMETRICS: discrepancy, consensus\n\"\"\")\n\n# At low p, many runs will be filtered out\nresults = run_protocol(guaranteed; p_values=0.5:0.1:1.0, repetitions=2000)\n\nUse Case: Study protocols under QoS guarantees or minimum connectivity assumptions.\n\n","category":"section"},{"location":"examples/overview/#Broadcast-Communication","page":"Overview","title":"Broadcast Communication","text":"All-or-nothing delivery per source.\n\nbroadcast = Protocol(\"\"\"\nPROTOCOL BroadcastAveraging\nPROCESSES: 4\nSTATE: x ‚àà ‚Ñù\nINITIAL VALUES: [0.0, 1.0, 2.0, 3.0]\nCHANNEL: stochastic\n\nMODEL:\n    broadcast probability=per_source\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS: discrepancy, consensus\n\"\"\")\n\nUse Case: Simulate atomic broadcast or correlated failures.\n\n","category":"section"},{"location":"examples/overview/#Hybrid-Models","page":"Overview","title":"Hybrid Models","text":"Different processes with different delivery characteristics.\n\nhybrid = Protocol(\"\"\"\nPROTOCOL HeterogeneousNetwork\nPROCESSES: 6\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nMODEL:\n    process 1: standard\n    process 2: standard\n    process 3: broadcast\n    process 4: broadcast\n    process 5: guaranteed k=3 scope=per_round\n    process 6: guaranteed k=3 scope=per_round\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS: discrepancy, consensus\n\"\"\")\n\nUse Case: Simulate heterogeneous networks with different node capabilities.\n\n","category":"section"},{"location":"examples/overview/#Advanced-Examples","page":"Overview","title":"Advanced Examples","text":"","category":"section"},{"location":"examples/overview/#Multi-Round-Convergence-Study","page":"Overview","title":"Multi-Round Convergence Study","text":"using StochProtocol\n\nproto = Protocol(\"\"\"\nPROTOCOL ConvergenceStudy\nPROCESSES: 20\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS: discrepancy, consensus\n\"\"\")\n\n# Study convergence over increasing rounds\nfor rounds in [1, 2, 5, 10, 20, 50]\n    results = run_protocol(proto;\n        rounds = rounds,\n        p_values = [0.7, 0.9],\n        repetitions = 1000\n    )\n\n    println(\"Rounds: $rounds\")\n    println(\"  p=0.7: E[D]=$(results[1].mean_discrepancy)\")\n    println(\"  p=0.9: E[D]=$(results[2].mean_discrepancy)\")\nend\n\n","category":"section"},{"location":"examples/overview/#Protocol-Comparison","page":"Overview","title":"Protocol Comparison","text":"using StochProtocol\n\n# Define multiple protocols\nprotocols = Dict(\n    \"AMP\" => Protocol(\"\"\"\n        PROTOCOL AMP\n        PROCESSES: 3\n        STATE: x ‚àà {0,1}\n        INITIAL VALUES: [0.0, 0.5, 1.0]\n        PARAMETERS: y = 0.5\n        CHANNEL: stochastic\n        UPDATE RULE:\n            EACH ROUND:\n                if received_diff then x·µ¢ ‚Üê y else x·µ¢ ‚Üê x end\n        METRICS: discrepancy, consensus\n    \"\"\"),\n\n    \"Averaging\" => Protocol(\"\"\"\n        PROTOCOL Averaging\n        PROCESSES: 3\n        STATE: x ‚àà ‚Ñù\n        INITIAL VALUES: [0.0, 0.5, 1.0]\n        CHANNEL: stochastic\n        UPDATE RULE:\n            EACH ROUND:\n                x·µ¢ ‚Üê avg(inbox_with_self)\n        METRICS: discrepancy, consensus\n    \"\"\"),\n\n    \"Minimum\" => Protocol(\"\"\"\n        PROTOCOL Minimum\n        PROCESSES: 3\n        STATE: x ‚àà ‚Ñù\n        INITIAL VALUES: [0.0, 0.5, 1.0]\n        CHANNEL: stochastic\n        UPDATE RULE:\n            EACH ROUND:\n                x·µ¢ ‚Üê min(inbox_with_self)\n        METRICS: discrepancy, consensus\n    \"\"\")\n)\n\n# Run all protocols\nall_results = []\np_range = 0.0:0.1:1.0\n\nfor (name, proto) in protocols\n    println(\"Running $name...\")\n    results = run_protocol(proto; p_values=p_range, repetitions=2000, seed=42)\n    push!(all_results, (name, results))\nend\n\n# Compare\nresults_comparison_table(all_results)\nplot_comparison(all_results; save_path=\"comparison.png\")\n\n","category":"section"},{"location":"examples/overview/#Parameter-Sweep","page":"Overview","title":"Parameter Sweep","text":"Explore how protocol parameters affect performance.\n\nfunction create_amp(y_value)\n    Protocol(\"\"\"\n    PROTOCOL AMP_y$(y_value)\n    PROCESSES: 2\n    STATE: x ‚àà {0,1}\n    INITIAL VALUES: [0.0, 1.0]\n    PARAMETERS: y = $y_value\n    CHANNEL: stochastic\n    UPDATE RULE:\n        EACH ROUND:\n            if received_diff then x·µ¢ ‚Üê y else x·µ¢ ‚Üê x end\n    METRICS: discrepancy, consensus\n    \"\"\")\nend\n\n# Sweep over y parameter\ny_values = 0.0:0.1:1.0\np_test = 0.8\n\nfor y in y_values\n    proto = create_amp(y)\n    results = run_protocol(proto; p_values=[p_test], repetitions=1000)\n    E_D = results[1].mean_discrepancy\n\n    println(\"y=$y, p=$p_test: E[D]=$E_D\")\nend\n\n","category":"section"},{"location":"examples/overview/#Real-World-Inspired-Examples","page":"Overview","title":"Real-World Inspired Examples","text":"","category":"section"},{"location":"examples/overview/#Sensor-Network-Averaging","page":"Overview","title":"Sensor Network Averaging","text":"sensor_net = Protocol(\"\"\"\nPROTOCOL SensorNetwork\nPROCESSES: 25\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = 20.0 + randn()  # Temperature readings with noise\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê 0.8 * x + 0.2 * avg(inbox)  # Weighted average\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")","category":"section"},{"location":"examples/overview/#Leader-Election-Simulation","page":"Overview","title":"Leader Election Simulation","text":"leader = Protocol(\"\"\"\nPROTOCOL LeaderElection\nPROCESSES: 10\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i  # Each process has unique ID\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê max(inbox_with_self)  # Propagate maximum ID\n\n    END:\n        # Leader is process with max ID\n        x·µ¢ ‚Üê max(inbox_with_self)\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\n","category":"section"},{"location":"examples/overview/#Running-the-Examples","page":"Overview","title":"Running the Examples","text":"All examples are available in the examples/ directory:\n\n# Run delivery models demo\njulia examples/delivery_models_demo.jl\n\n# Run quickstart examples\njulia examples/quickstart.jl\n\n# Run protocol comparison\njulia examples/literature_protocols.jl\n\n","category":"section"},{"location":"examples/overview/#Creating-Your-Own-Examples","page":"Overview","title":"Creating Your Own Examples","text":"","category":"section"},{"location":"examples/overview/#Template","page":"Overview","title":"Template","text":"using StochProtocol\n\nmy_protocol = Protocol(\"\"\"\nPROTOCOL MyProtocol\nPROCESSES: N\nSTATE: x ‚àà Domain\nINITIAL VALUES: [...]\nCHANNEL: stochastic\n\nMODEL:\n    # Optional delivery model\n\nUPDATE RULE:\n    EACH ROUND:\n        # Your update logic\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\n# Experiment\nresults = run_protocol(my_protocol;\n    p_values = 0.0:0.1:1.0,\n    rounds = 1,\n    repetitions = 2000\n)\n\n# Analyze\nresults_table(results)\nplot_discrepancy_vs_p(results)\n\n","category":"section"},{"location":"examples/overview/#See-Also","page":"Overview","title":"See Also","text":"Quick Start - Get started in 5 minutes\nProtocol DSL - Language reference\nDelivery Models - Communication models\nExperiments Guide - Running simulations","category":"section"},{"location":"advanced/tracing/#Tracing-and-Debugging","page":"Tracing & Debugging","title":"Tracing & Debugging","text":"Detailed execution tracing and debugging tools for protocol development.","category":"section"},{"location":"advanced/tracing/#Overview","page":"Tracing & Debugging","title":"Overview","text":"The Tracing module provides deep visibility into protocol execution, making it easy to understand exactly what happens at each step, debug unexpected behaviors, and create visualizations.","category":"section"},{"location":"advanced/tracing/#Trace-Levels","page":"Tracing & Debugging","title":"Trace Levels","text":"Control verbosity of tracing:\n\nusing StochProtocol\n\n# Available levels:\nNoTrace()         # No tracing (default)\nBasicTrace()      # Only major events\nDetailedTrace()   # Message-level details\nVerboseTrace()    # Everything including internals\n\n# Enable tracing\nenable_tracing(DetailedTrace())\n\n# Disable tracing\ndisable_tracing()\n\n# Change level\nset_trace_level(VerboseTrace())","category":"section"},{"location":"advanced/tracing/#Trace-Execution","page":"Tracing & Debugging","title":"Trace Execution","text":"Run protocol with full execution trace:\n\ntrace = trace_execution(protocol;\n    n_processes = 5,\n    p = 0.7,\n    rounds = 10,\n    seed = UInt32(42)  # For reproducibility\n)\n\nThis returns an ExecutionTrace object containing complete execution history.","category":"section"},{"location":"advanced/tracing/#Trace-Data-Structure","page":"Tracing & Debugging","title":"Trace Data Structure","text":"struct ExecutionTrace\n    protocol_name::String\n    n_processes::Int\n    p_value::Float64\n    seed::UInt32\n    rounds::Vector{RoundTrace}  # Per-round data\n    initial_states::Vector{Float64}\n    final_states::Vector{Float64}\n    total_messages::Int\n    delivered_messages::Int\n    metadata::Dict{String, Any}\nend\n\nEach round contains:\n\nstruct RoundTrace\n    round::Int\n    messages::Vector{MessageTrace}      # All messages sent/received\n    state_changes::Vector{StateChange}  # State updates\n    discrepancy::Float64\n    consensus_reached::Bool\n    metadata::Dict{String, Any}\nend","category":"section"},{"location":"advanced/tracing/#Message-Flow-Diagram","page":"Tracing & Debugging","title":"Message Flow Diagram","text":"Visualize message passing for a specific round:\n\n# Show message flow for round 5\nmessage_flow_diagram(trace; round=5)\n\nExample output:\n\n============================================================\nMessage Flow - Round 5\n============================================================\n\nProcess 1 (value: 1.450)\n  ‚úì P1 ‚îÄ‚îÄ‚Üí P2  [1.450]\n  ‚úì P1 ‚îÄ‚îÄ‚Üí P3  [1.450]\n  ‚úó P1 ‚îÄ‚§´‚Üí P4  [1.450]  # Not delivered\n\nProcess 2 (value: 2.300)\n  ‚úì P2 ‚îÄ‚îÄ‚Üí P1  [2.300]\n  ‚úì P2 ‚îÄ‚îÄ‚Üí P3  [2.300]\n\n...\n\n============================================================\nDiscrepancy: 0.123456\nMessages: 20 sent, 14 delivered (70.0%)\n============================================================\n\nSymbols:\n\n‚úì = Message delivered\n‚úó = Message lost\n‚îÄ‚îÄ‚Üí = Successful delivery\n‚îÄ‚§´‚Üí = Failed delivery","category":"section"},{"location":"advanced/tracing/#State-Evolution-Table","page":"Tracing & Debugging","title":"State Evolution Table","text":"See how each process's state changes over time:\n\nstate_evolution_table(trace)\n\nExample output:\n\n================================================================================\nState Evolution\n================================================================================\nRound | P1     | P2     | P3     | P4     | P5     | Discrepancy\n--------------------------------------------------------------------------------\n  0   | 1.000  | 2.000  | 3.000  | 4.000  | 5.000  | 4.000000\n  1   | 1.500  | 2.000  | 2.750  | 3.500  | 4.250  | 2.750000\n  2   | 1.750  | 2.125  | 2.500  | 3.125  | 3.625  | 1.875000\n  3   | 2.000  | 2.250  | 2.500  | 2.875  | 3.250  | 1.250000\n  4   | 2.125  | 2.375  | 2.500  | 2.750  | 3.000  | 0.875000\n  5   | 2.250  | 2.438  | 2.562  | 2.688  | 2.875  | 0.625000\n  6   | 2.344  | 2.469  | 2.562  | 2.656  | 2.781  | 0.437000\n  7   | 2.406  | 2.484  | 2.547  | 2.625  | 2.719  | 0.313000\n  8   | 2.445  | 2.492  | 2.531  | 2.594  | 2.672  | 0.227000\n  9   | 2.471  | 2.496  | 2.520  | 2.570  | 2.633  | 0.162000\n 10   | 2.489  | 2.498  | 2.512  | 2.551  | 2.602  | 0.113000 ‚úì CONSENSUS\n================================================================================","category":"section"},{"location":"advanced/tracing/#Trace-Summary","page":"Tracing & Debugging","title":"Trace Summary","text":"High-level overview:\n\ntrace_summary(trace)\n\nOutput:\n\n============================================================\nExecution Trace Summary\n============================================================\nProtocol: AveragingProtocol\nProcesses: 5\nDelivery probability: 0.70\nSeed: 42\nRounds executed: 10\nTotal messages: 200 sent, 140 delivered (70.0%)\n\nInitial discrepancy: 4.0\nFinal discrepancy: 0.113\nConsensus reached: Round 10\n============================================================","category":"section"},{"location":"advanced/tracing/#Anomaly-Detection","page":"Tracing & Debugging","title":"Anomaly Detection","text":"Automatically detect potential issues:\n\nanomalies = detect_anomalies(trace)\n\nfor anomaly in anomalies\n    println(\"‚ö†Ô∏è  \", anomaly)\nend\n\nDetects:\n\nProcesses that never receive messages\nNon-decreasing discrepancy (convergence failure)\nVery low delivery rates\nProcesses that never update state\nOther unexpected behaviors\n\nExample output:\n\n‚ö†Ô∏è  Process 3 never received any messages\n‚ö†Ô∏è  Discrepancy increased at round 7\n‚ö†Ô∏è  Low delivery rate: 35.0%","category":"section"},{"location":"advanced/tracing/#Filter-Trace","page":"Tracing & Debugging","title":"Filter Trace","text":"Focus on specific process or round:\n\n# Filter by process\ntrace_p3 = filter_trace(trace; process=3)\n\n# Filter by round\ntrace_r5 = filter_trace(trace; round=5)\n\n# Both\ntrace_p3_r5 = filter_trace(trace; process=3, round=5)","category":"section"},{"location":"advanced/tracing/#Export-Trace","page":"Tracing & Debugging","title":"Export Trace","text":"Save trace for external analysis:\n\n# Export to JSON\nexport_trace(trace, \"execution.json\"; format=:json)\n\n# Export to CSV\nexport_trace(trace, \"execution.csv\"; format=:csv)","category":"section"},{"location":"advanced/tracing/#Example:-Debugging-Convergence-Failure","page":"Tracing & Debugging","title":"Example: Debugging Convergence Failure","text":"using StochProtocol\n\nprotocol = Protocol(\"\"\"\nPROTOCOL DebugProtocol\nPROCESSES: 5\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS:\n    discrepancy\n\"\"\")\n\n# Enable detailed tracing\nenable_tracing(DetailedTrace())\n\n# Run with low p (might not converge)\ntrace = trace_execution(protocol;\n    n_processes = 5,\n    p = 0.2,  # Very low delivery probability\n    rounds = 20,\n    seed = UInt32(123)\n)\n\n# Analyze\nprintln(\"\\nüìä TRACE SUMMARY\")\ntrace_summary(trace)\n\nprintln(\"\\nüîç DETECTED ANOMALIES\")\nanomalies = detect_anomalies(trace)\nif isempty(anomalies)\n    println(\"‚úÖ No anomalies detected\")\nelse\n    for anomaly in anomalies\n        println(\"‚ö†Ô∏è  \", anomaly)\n    end\nend\n\nprintln(\"\\nüìà STATE EVOLUTION\")\nstate_evolution_table(trace)\n\n# Check specific rounds with issues\nprintln(\"\\nüì® MESSAGE FLOW - ROUND 5\")\nmessage_flow_diagram(trace; round=5)\n\nprintln(\"\\nüì® MESSAGE FLOW - ROUND 15\")\nmessage_flow_diagram(trace; round=15)","category":"section"},{"location":"advanced/tracing/#Example:-Comparing-Different-Seeds","page":"Tracing & Debugging","title":"Example: Comparing Different Seeds","text":"# Trace two runs with different seeds\ntrace1 = trace_execution(protocol; p=0.7, rounds=15, seed=UInt32(1))\ntrace2 = trace_execution(protocol; p=0.7, rounds=15, seed=UInt32(2))\n\nprintln(\"Run 1:\")\nprintln(\"  Final discrepancy: \", trace1.rounds[end].discrepancy)\nprintln(\"  Consensus at round: \", findfirst(r -> r.consensus_reached, trace1.rounds))\n\nprintln(\"\\nRun 2:\")\nprintln(\"  Final discrepancy: \", trace2.rounds[end].discrepancy)\nprintln(\"  Consensus at round: \", findfirst(r -> r.consensus_reached, trace2.rounds))","category":"section"},{"location":"advanced/tracing/#Best-Practices","page":"Tracing & Debugging","title":"Best Practices","text":"Use for Development: Enable tracing during protocol development\nDisable for Performance: Turn off tracing for large-scale experiments\nStart with Summary: Use trace_summary() first, then drill down\nCheck Anomalies: Always run detect_anomalies() on failed runs\nReproducible Seeds: Use fixed seeds when debugging\nFilter Large Traces: Use filter_trace() for protocols with many processes/rounds","category":"section"},{"location":"advanced/tracing/#Performance-Notes","page":"Tracing & Debugging","title":"Performance Notes","text":"Tracing adds overhead:\n\nNoTrace: Zero overhead\nBasicTrace: ~5-10% overhead\nDetailedTrace: ~20-30% overhead\nVerboseTrace: ~50%+ overhead\n\nFor production experiments with thousands of repetitions, keep tracing disabled.\n\nFor debugging and understanding, detailed tracing is invaluable.","category":"section"},{"location":"guides/colab_optimization/#Google-Colab-Optimization-Guide","page":"Google Colab Setup","title":"Google Colab Optimization Guide","text":"Tips and tricks for using StochProtocol.jl efficiently in Google Colab.","category":"section"},{"location":"guides/colab_optimization/#Why-is-Colab-Slow?","page":"Google Colab Setup","title":"Why is Colab Slow?","text":"Google Colab is designed for Python. When using Julia:\n\nMust download and install Julia runtime (~100 MB)\nMust download all package dependencies (~200-500 MB)\nMust precompile everything from scratch\nEnvironment resets on disconnect\n\nFirst run: ~5-10 minutes Subsequent runs (same session): ~30 seconds","category":"section"},{"location":"guides/colab_optimization/#Quick-Start-(Optimized)","page":"Google Colab Setup","title":"Quick Start (Optimized)","text":"Use our pre-configured notebook:\n\n(Image: Open In Colab)\n\nThis notebook includes:\n\nFast Julia installation\nMinimal dependencies\nOptimized precompilation\nExample workflows","category":"section"},{"location":"guides/colab_optimization/#Manual-Installation-(Fastest-Method)","page":"Google Colab Setup","title":"Manual Installation (Fastest Method)","text":"","category":"section"},{"location":"guides/colab_optimization/#Cell-1:-Install-Julia","page":"Google Colab Setup","title":"Cell 1: Install Julia","text":"%%shell\n# Install Julia 1.10 (only needed first time)\nif [ ! -x \"$(command -v julia)\" ]; then\n    wget -q https://julialang-s3.julialang.org/bin/linux/x64/1.10/julia-1.10.0-linux-x86_64.tar.gz\n    tar -xzf julia-1.10.0-linux-x86_64.tar.gz\n    sudo mv julia-1.10.0 /opt/julia\n    sudo ln -s /opt/julia/bin/julia /usr/local/bin/julia\n    rm julia-1.10.0-linux-x86_64.tar.gz\nfi\njulia --version","category":"section"},{"location":"guides/colab_optimization/#Cell-2:-Install-StochProtocol-(Fast)","page":"Google Colab Setup","title":"Cell 2: Install StochProtocol (Fast)","text":"%%shell\njulia -e '\nusing Pkg\nPkg.activate(temp=true)\n\n# Skip auto-precompilation (do it manually later)\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"] = \"0\"\n\n# Install from GitHub\nPkg.add(url=\"https://github.com/notGiGi/StochProtocol.jl\")\nPkg.add(\"Plots\")\n\n# Precompile only essentials\nPkg.precompile([\"StochProtocol\", \"Plots\"])\n'\n\nTime: ~2-3 minutes (vs 30+ minutes with standard install)","category":"section"},{"location":"guides/colab_optimization/#Cell-3:-Use-StochProtocol","page":"Google Colab Setup","title":"Cell 3: Use StochProtocol","text":"using StochProtocol\nusing Plots\n\n# Your code here\nprotocol = Protocol(\"\"\"\nPROTOCOL MyProtocol\nPROCESSES: 5\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS:\n    discrepancy\n\"\"\")\n\nresults = run_protocol(protocol;\n    p_values = 0.5:0.1:1.0,\n    rounds = 20,\n    repetitions = 500\n)\n\nresults_table(results)","category":"section"},{"location":"guides/colab_optimization/#Optimization-Tips","page":"Google Colab Setup","title":"Optimization Tips","text":"","category":"section"},{"location":"guides/colab_optimization/#1.-Use-GR-Backend-for-Plots","page":"Google Colab Setup","title":"1. Use GR Backend for Plots","text":"# Add to top of notebook\nENV[\"GKSwstype\"] = \"100\"  # Headless GR backend\nusing Plots\ngr()  # Use GR backend (fastest for Colab)","category":"section"},{"location":"guides/colab_optimization/#2.-Reduce-Repetitions-for-Prototyping","page":"Google Colab Setup","title":"2. Reduce Repetitions for Prototyping","text":"# During development - fast iterations\nresults = run_protocol(protocol; repetitions=100)\n\n# For final results - accuracy\nresults = run_protocol(protocol; repetitions=2000)","category":"section"},{"location":"guides/colab_optimization/#3.-Cache-Results","page":"Google Colab Setup","title":"3. Cache Results","text":"# Run expensive computation once\nif !@isdefined(cached_results)\n    global cached_results = run_protocol(protocol; repetitions=2000)\nend\n\n# Use cached results\nplot_discrepancy_vs_p(cached_results)","category":"section"},{"location":"guides/colab_optimization/#4.-Use-Fewer-Processes-for-Testing","page":"Google Colab Setup","title":"4. Use Fewer Processes for Testing","text":"# Fast testing with 3 processes\nPROTOCOL TestProtocol\nPROCESSES: 3\n...\n\n# Production with 20 processes\nPROTOCOL ProductionProtocol\nPROCESSES: 20\n...","category":"section"},{"location":"guides/colab_optimization/#5.-Persistent-Depot-(Advanced)","page":"Google Colab Setup","title":"5. Persistent Depot (Advanced)","text":"Keep packages across sessions using Google Drive:\n\nfrom google.colab import drive\ndrive.mount('/content/drive')\n\n# Set Julia depot to Google Drive\nimport os\nos.environ['JULIA_DEPOT_PATH'] = '/content/drive/MyDrive/julia_depot'\n\nThen packages persist between sessions!","category":"section"},{"location":"guides/colab_optimization/#Troubleshooting","page":"Google Colab Setup","title":"Troubleshooting","text":"","category":"section"},{"location":"guides/colab_optimization/#\"Package-took-too-long-to-precompile\"","page":"Google Colab Setup","title":"\"Package took too long to precompile\"","text":"Solution: Skip auto-precompilation\n\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"] = \"0\"\nusing Pkg\nPkg.add(\"StochProtocol\")\n# Manually precompile later\nPkg.precompile()","category":"section"},{"location":"guides/colab_optimization/#\"Out-of-Memory\"","page":"Google Colab Setup","title":"\"Out of Memory\"","text":"Solution 1: Use fewer repetitions\n\nresults = run_protocol(protocol; repetitions=500)  # Instead of 2000\n\nSolution 2: Use Colab Pro (more RAM)","category":"section"},{"location":"guides/colab_optimization/#\"Session-Disconnected\"","page":"Google Colab Setup","title":"\"Session Disconnected\"","text":"Colab disconnects after 90 minutes of inactivity.\n\nSolution: Keep session alive with this JavaScript:\n\n// In browser console (F12)\nfunction KeepClicking(){\n    console.log(\"Clicking\");\n    document.querySelector(\"colab-connect-button\").click();\n}\nsetInterval(KeepClicking, 60000);  // Click every 60 seconds","category":"section"},{"location":"guides/colab_optimization/#First-Load-Still-Slow","page":"Google Colab Setup","title":"First Load Still Slow","text":"Solution: Use Binder instead\n\nBinder is better optimized for Julia than Colab:\n\n(Image: Binder)\n\nNo account needed\nJulia-native environment\nFaster initial load (~2 minutes)\nInteractive Pluto.jl interface","category":"section"},{"location":"guides/colab_optimization/#Comparison:-Colab-vs-Binder-vs-Local","page":"Google Colab Setup","title":"Comparison: Colab vs Binder vs Local","text":"Feature Colab Binder Local\nFirst load 5-10 min 2-3 min 1 min\nSubsequent loads 30 sec 30 sec instant\nRequires account Yes (Google) No No\nSession timeout 90 min idle 10 min idle Never\nRAM 12 GB (free) / 25 GB (Pro) ~2 GB Unlimited\nStorage 15 GB (Google Drive) Temporary Unlimited\nGPU Yes (free) No Depends\nBest for Large experiments Quick demos Development","category":"section"},{"location":"guides/colab_optimization/#Recommendation","page":"Google Colab Setup","title":"Recommendation","text":"For your researchers (older, non-technical):\n\nFirst choice: Binder + Pluto.jl\nNo account needed\nFastest for demos\nInteractive interface\nJust click and wait 2 minutes\nSecond choice: Colab with optimized notebook\nIf they already have Google account\nBetter for long experiments (no 10min timeout)\nMore RAM for large simulations\nAvoid: Manual Colab setup\nToo slow and complicated\n30+ minute install time\nLots of command-line work","category":"section"},{"location":"guides/colab_optimization/#Example:-Optimized-Colab-Workflow","page":"Google Colab Setup","title":"Example: Optimized Colab Workflow","text":"# === CELL 1: One-time setup ===\n# Run this once per session\n\nusing Pkg\nPkg.activate(temp=true)\nENV[\"JULIA_PKG_PRECOMPILE_AUTO\"] = \"0\"\nPkg.add(url=\"https://github.com/notGiGi/StochProtocol.jl\")\nPkg.add(\"Plots\")\nPkg.precompile()\n\n# === CELL 2: Load packages ===\nusing StochProtocol\nusing Plots\nENV[\"GKSwstype\"] = \"100\"\ngr()\n\n# === CELL 3: Define protocol ===\nprotocol = Protocol(\"\"\"\nPROTOCOL AveragingProtocol\nPROCESSES: 5\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS:\n    discrepancy\n\"\"\")\n\n# === CELL 4: Run experiments ===\nresults = run_protocol(protocol;\n    p_values = 0.5:0.1:1.0,\n    rounds = 20,\n    repetitions = 1000\n)\n\n# === CELL 5: Visualize ===\nresults_table(results)\nplot_discrepancy_vs_p(results)\n\nTotal time: ~3-4 minutes from start to results.","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"This guide will walk you through using StochProtocol.jl to define, simulate, and analyze distributed consensus protocols.","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"using Pkg\nPkg.add(\"StochProtocol\")","category":"section"},{"location":"getting_started/#Your-First-Protocol","page":"Getting Started","title":"Your First Protocol","text":"Let's implement the AMP (Averaging Meeting Point) protocol:\n\nusing StochProtocol\n\n# Define the protocol using the Protocol wrapper\nAMP = Protocol(\"\"\"\nPROTOCOL AMP\nPROCESSES: 2\nSTATE:\n    x ‚àà {0,1}\nINITIAL VALUES:\n    [0.0, 1.0]\nPARAMETERS:\n    y ‚àà [0,1] = 0.5\nCHANNEL:\n    stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then\n            x·µ¢ ‚Üê y\n        else\n            x·µ¢ ‚Üê x\n        end\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\nWhen you display AMP in a notebook, you'll see:\n\n‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ  Protocol: AMP                                             ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n  PROTOCOL AMP\n  PROCESSES: 2\n  STATE:\n      x ‚àà {0,1}\n  ...\n\n  ‚úì Protocol loaded and ready to run","category":"section"},{"location":"getting_started/#Running-Experiments","page":"Getting Started","title":"Running Experiments","text":"Run the protocol across different message delivery probabilities:\n\nresults = run_protocol(AMP;\n                       p_values=0.0:0.1:1.0,  # Range of probabilities\n                       rounds=1,               # Number of rounds\n                       repetitions=2000)       # Monte Carlo samples","category":"section"},{"location":"getting_started/#Parameters","page":"Getting Started","title":"Parameters","text":"p_values: Probability range or list (e.g., 0.0:0.1:1.0 or [0.2, 0.5, 0.8])\nrounds: Number of communication rounds\nrepetitions: Number of Monte Carlo simulations per p-value\nseed: (Optional) Random seed for reproducibility","category":"section"},{"location":"getting_started/#Viewing-Results","page":"Getting Started","title":"Viewing Results","text":"","category":"section"},{"location":"getting_started/#Interactive-Tables","page":"Getting Started","title":"Interactive Tables","text":"results_table(results; protocol_name=\"AMP (y=0.5)\")\n\nOutput in Jupyter:\n\nResults: AMP (y=0.5)\n\n11√ó4 DataFrame (interactive, colored)\n Row ‚îÇ p        E_D      P_consensus  Trials\n     ‚îÇ Float64  Float64  Float64      Int64\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1 ‚îÇ     0.0   1.0           0.0      2000\n   2 ‚îÇ     0.1   0.9       0.00015      2000\n   3 ‚îÇ     0.2   0.8        0.0032      2000\n  ...","category":"section"},{"location":"getting_started/#Plots","page":"Getting Started","title":"Plots","text":"# Discrepancy plot\nplot_discrepancy_vs_p(results;\n                      title=\"AMP: Expected Discrepancy vs p\",\n                      save_path=\"amp_discrepancy.png\")\n\n# Consensus probability plot\nplot_consensus_vs_p(results;\n                    title=\"AMP: Consensus Probability vs p\",\n                    save_path=\"amp_consensus.png\")\n\nAll plots are 300 DPI and ready for publication!","category":"section"},{"location":"getting_started/#Comparing-Protocols","page":"Getting Started","title":"Comparing Protocols","text":"# Define another protocol\nFV = Protocol(\"\"\"\nPROTOCOL FV\nPROCESSES: 2\nSTATE:\n    x ‚àà {0,1}\nINITIAL VALUES:\n    [0.0, 1.0]\nCHANNEL:\n    stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then\n            x·µ¢ ‚Üê received_other(x)\n        else\n            x·µ¢ ‚Üê x\n        end\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\nresults_fv = run_protocol(FV; p_values=0.0:0.1:1.0, repetitions=2000)\n\n# Comparison table\nresults_comparison_table(Dict(\n    \"AMP\" => results,\n    \"FV\" => results_fv\n))\n\n# Comparison plot\nplot_comparison(\n    Dict(\"AMP\" => results, \"FV\" => results_fv);\n    metric=:discrepancy,\n    save_path=\"amp_vs_fv.png\"\n)","category":"section"},{"location":"getting_started/#Jupyter-Notebooks","page":"Getting Started","title":"Jupyter Notebooks","text":"For the best experience, use StochProtocol in Jupyter notebooks:\n\nInteractive tables - DataFrames with colors and sorting\nInline plots - See results immediately\n\nExample notebook setup:\n\nusing Pkg\nPkg.activate(\".\")\nusing StochProtocol\n\n# Define, run, visualize\nAMP = Protocol(\"\"\"...\"\"\")\nresults = run_protocol(AMP; p_values=0.0:0.1:1.0)\nresults_table(results)","category":"section"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"Get up and running with StochProtocol.jl in 5 minutes.","category":"section"},{"location":"quickstart/#Installation","page":"Quick Start","title":"Installation","text":"julia> using Pkg\n\njulia> Pkg.add(\"StochProtocol\")","category":"section"},{"location":"quickstart/#Your-First-Protocol","page":"Quick Start","title":"Your First Protocol","text":"Let's analyze the AMP (Averaging Meeting Point) protocol.","category":"section"},{"location":"quickstart/#Step-1:-Load-the-Package","page":"Quick Start","title":"Step 1: Load the Package","text":"using StochProtocol","category":"section"},{"location":"quickstart/#Step-2:-Define-the-Protocol","page":"Quick Start","title":"Step 2: Define the Protocol","text":"Use the Protocol() wrapper for beautiful display:\n\nAMP = Protocol(\"\"\"\nPROTOCOL AMP\nPROCESSES: 2\nSTATE:\n    x ‚àà {0,1}\nINITIAL VALUES:\n    [0.0, 1.0]\nPARAMETERS:\n    y ‚àà [0,1] = 0.5\nCHANNEL:\n    stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then\n            x·µ¢ ‚Üê y\n        else\n            x·µ¢ ‚Üê x\n        end\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\nWhen you display AMP, you'll see:\n\n‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ  Protocol: AMP                                             ‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n  PROTOCOL AMP\n  PROCESSES: 2\n  STATE:\n      x ‚àà {0,1}\n  ...\n\n  ‚úì Protocol loaded and ready to run","category":"section"},{"location":"quickstart/#Step-3:-Run-Experiments","page":"Quick Start","title":"Step 3: Run Experiments","text":"results = run_protocol(AMP;\n                       p_values=0.0:0.1:1.0,  # Message delivery probabilities\n                       rounds=1,               # Communication rounds\n                       repetitions=2000)       # Monte Carlo samples\n\ntip: Parameter Shortcuts\np_values accepts ranges: 0.0:0.1:1.0 or lists: [0.2, 0.5, 0.8]\nseed is optional - omit for random, specify for reproducibility\nDefault repetitions=2000 balances speed and accuracy","category":"section"},{"location":"quickstart/#Step-4:-View-Results","page":"Quick Start","title":"Step 4: View Results","text":"Interactive Table (beautiful in Jupyter!):\n\nresults_table(results; protocol_name=\"AMP (y=0.5)\")\n\nOutput:\n\nResults: AMP (y=0.5)\n\n11√ó4 DataFrame (colored & interactive in Jupyter)\n Row ‚îÇ p        E_D       P_consensus  Trials\n     ‚îÇ Float64  Float64   Float64      Int64\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n   1 ‚îÇ     0.0  1.0             0.0      2000\n   2 ‚îÇ     0.1  0.9        0.00015      2000\n  ...\n\nPublication Plot:\n\nplot_discrepancy_vs_p(results;\n                      title=\"AMP: Expected Discrepancy vs p\",\n                      save_path=\"amp_discrepancy.png\")\n\nThe plot is automatically:\n\n‚úÖ Professional styling\n‚úÖ Saved as PNG\n‚úÖ Displayed inline (in Jupyter)","category":"section"},{"location":"quickstart/#What's-Next?","page":"Quick Start","title":"What's Next?","text":"","category":"section"},{"location":"quickstart/#Compare-Protocols","page":"Quick Start","title":"Compare Protocols","text":"# Define FV protocol\nFV = Protocol(\"\"\"\nPROTOCOL FV\nPROCESSES: 2\nSTATE:\n    x ‚àà {0,1}\nINITIAL VALUES:\n    [0.0, 1.0]\nCHANNEL:\n    stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then\n            x·µ¢ ‚Üê received_other(x)\n        else\n            x·µ¢ ‚Üê x\n        end\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\nresults_fv = run_protocol(FV; p_values=0.0:0.1:1.0, repetitions=2000)\n\n# Side-by-side comparison\nresults_comparison_table(Dict(\n    \"AMP\" => results,\n    \"FV\" => results_fv\n))\n\n# Comparative plot\nplot_comparison(\n    Dict(\"AMP\" => results, \"FV\" => results_fv);\n    metric=:discrepancy,\n    save_path=\"comparison.png\"\n)","category":"section"},{"location":"quickstart/#Jupyter-Notebook-Setup","page":"Quick Start","title":"Jupyter Notebook Setup","text":"using Pkg\nPkg.activate(\".\")  # Activate project environment\nusing StochProtocol\n\n# Define, run, visualize - no semicolons needed!\nAMP = Protocol(\"\"\"...\"\"\")\nresults = run_protocol(AMP; p_values=0.0:0.1:1.0)\nresults_table(results)","category":"section"},{"location":"quickstart/#Reproducible-Research","page":"Quick Start","title":"Reproducible Research","text":"# Fixed seed for reproducibility\nresults = run_protocol(AMP;\n                       p_values=0.0:0.05:1.0,\n                       repetitions=5000,\n                       seed=42)  # Same results every time","category":"section"},{"location":"quickstart/#Parameter-Sweeps","page":"Quick Start","title":"Parameter Sweeps","text":"# Analyze how parameter y affects performance\nfor y in [0.3, 0.4, 0.5, 0.6, 0.7]\n    protocol = make_amp_protocol(y)  # Helper function\n    results = run_protocol(protocol; p_values=0.0:0.1:1.0)\n    plot_discrepancy_vs_p(results;\n                          title=\"AMP (y=$y)\",\n                          save_path=\"amp_y$(y).png\")\nend","category":"section"},{"location":"quickstart/#Tips-and-Tricks","page":"Quick Start","title":"Tips & Tricks","text":"tip: Protocol() Display\nUse Protocol(\"\"\"...\"\"\") instead of plain strings - it displays beautifully without needing ;\n\ntip: Jupyter Tables\nIn Jupyter, results_table() returns an interactive DataFrame with:‚úÖ Colored headers\n‚úÖ Sortable columns\n‚úÖ Hover tooltips\n‚úÖ Easy copy/paste\n\ntip: Fast Iteration\nUse fewer repetitions (e.g., 500) while developing, then increase to 5000+ for final results.\n\nwarning: Memory Usage\nVery large parameter sweeps (many p-values √ó high repetitions √ó many rounds) can use significant memory. Start small and scale up.","category":"section"},{"location":"guides/dsl/#Protocol-DSL-Reference","page":"Protocol DSL","title":"Protocol DSL Reference","text":"Complete reference for the StochProtocol protocol specification language\n\n","category":"section"},{"location":"guides/dsl/#Overview","page":"Protocol DSL","title":"Overview","text":"The Protocol DSL lets you define distributed consensus protocols using mathematical notation that mirrors research papers.\n\n<div class=\"admonition is-info\">\n    <div class=\"admonition-header\">‚ú® Design Philosophy</div>\n    <p><strong>No boilerplate code‚Äîjust the essential protocol logic.</strong> Write protocols the way you think about them, using the same notation you'd use in a paper.</p>\n</div>","category":"section"},{"location":"guides/dsl/#Basic-Structure","page":"Protocol DSL","title":"Basic Structure","text":"PROTOCOL <Name>                      # Protocol identifier\nPROCESSES: <N>                       # Number of processes\nSTATE: <variable> ‚àà <domain>         # State variable and domain\nINITIAL VALUES: [v1, v2, ..., vN]    # Explicit initial values\n  # OR\nINITIAL: <expression>                # Formula-based initialization\n\nPARAMETERS: <params>                 # Optional parameters\nCHANNEL: stochastic                  # Channel type\nMODEL: <delivery_model>              # Optional delivery model\n\nUPDATE RULE:\n    <phase>:                         # When to execute\n        <rule>                       # How to update state\n\nMETRICS: <metric1>, <metric2>        # What to measure\n\n<div class=\"admonition is-success\">\n    <div class=\"admonition-header\">üí° Quick Tip</div>\n    <p>Start with the simplest possible protocol, then add complexity incrementally. Every section except PARAMETERS and MODEL is required.</p>\n</div>\n\n","category":"section"},{"location":"guides/dsl/#Sections","page":"Protocol DSL","title":"Sections","text":"","category":"section"},{"location":"guides/dsl/#PROTOCOL","page":"Protocol DSL","title":"PROTOCOL","text":"PROTOCOL <ProtocolName>\n\nRequired. Defines the protocol name.\n\nExample:\n\nPROTOCOL AMP\nPROTOCOL SimpleAveraging\nPROTOCOL FV_Protocol\n\n","category":"section"},{"location":"guides/dsl/#PROCESSES","page":"Protocol DSL","title":"PROCESSES","text":"PROCESSES: <N>\n\nRequired. Specifies the number of processes in the system.\n\nExample:\n\nPROCESSES: 2\nPROCESSES: 10\nPROCESSES: 100\n\n","category":"section"},{"location":"guides/dsl/#STATE","page":"Protocol DSL","title":"STATE","text":"STATE:\n    <variable> ‚àà <domain>\n\nRequired. Declares the state variable and its domain.\n\nSupported Domains:\n\n{0,1} - Binary values\n‚Ñù or R - Real numbers\n[a,b] - Interval (parsed as real)\n\nExample:\n\nSTATE:\n    x ‚àà {0,1}\n\nSTATE:\n    x ‚àà ‚Ñù\n\nSTATE:\n    value ‚àà [0,1]\n\n","category":"section"},{"location":"guides/dsl/#INITIAL-VALUES-/-INITIAL","page":"Protocol DSL","title":"INITIAL VALUES / INITIAL","text":"Two ways to initialize state:","category":"section"},{"location":"guides/dsl/#Option-1:-Explicit-Values","page":"Protocol DSL","title":"Option 1: Explicit Values","text":"INITIAL VALUES:\n    [v1, v2, ..., vN]\n\nProvide explicit initial values for each process.\n\nExample:\n\nINITIAL VALUES:\n    [0.0, 1.0]          # 2 processes\n\nINITIAL VALUES:\n    [0.0, 0.5, 1.0]     # 3 processes","category":"section"},{"location":"guides/dsl/#Option-2:-Formula","page":"Protocol DSL","title":"Option 2: Formula","text":"INITIAL:\n    x·µ¢ = <expression in i>\n\nUse a formula where i is the process ID (1-indexed).\n\nExample:\n\nINITIAL:\n    x·µ¢ = i              # Process i starts with value i\n\nINITIAL:\n    x·µ¢ = i / N          # Normalized by number of processes\n\nINITIAL:\n    x·µ¢ = (i - 1) * 0.1  # 0.0, 0.1, 0.2, ...\n\n","category":"section"},{"location":"guides/dsl/#PARAMETERS","page":"Protocol DSL","title":"PARAMETERS","text":"PARAMETERS:\n    <param> ‚àà <domain> = <default>\n\nOptional. Define protocol parameters (e.g., meeting points).\n\nExample:\n\nPARAMETERS:\n    y ‚àà [0,1] = 0.5\n\nPARAMETERS:\n    alpha = 0.3\n    beta ‚àà ‚Ñù = 1.0\n\nAccess parameters in update rules:\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê y          # Use parameter y\n\n","category":"section"},{"location":"guides/dsl/#CHANNEL","page":"Protocol DSL","title":"CHANNEL","text":"CHANNEL:\n    stochastic\n\nRequired. Currently only stochastic (Bernoulli) channels are supported.\n\n","category":"section"},{"location":"guides/dsl/#MODEL","page":"Protocol DSL","title":"MODEL","text":"MODEL:\n    <model_specification>\n\nOptional. Specifies the message delivery model. Defaults to standard if omitted.","category":"section"},{"location":"guides/dsl/#Standard-Model-(Default)","page":"Protocol DSL","title":"Standard Model (Default)","text":"MODEL:\n    standard\n\nIndependent probabilistic delivery for each message.","category":"section"},{"location":"guides/dsl/#Guaranteed-Model","page":"Protocol DSL","title":"Guaranteed Model","text":"MODEL:\n    guaranteed k=<N> scope=<per_round|total>\n\nEnsures minimum k messages delivered.\n\nParameters:\n\nk: Minimum messages required\nscope:\nper_round: Guarantee applies each round\ntotal: Guarantee applies to sum across all rounds\n\nExample:\n\nMODEL:\n    guaranteed k=3 scope=per_round\n\nFilters out simulation runs where any round has < 3 messages delivered.","category":"section"},{"location":"guides/dsl/#Broadcast-Model","page":"Protocol DSL","title":"Broadcast Model","text":"MODEL:\n    broadcast probability=<per_source|uniform>\n\nAll-or-nothing delivery per source process.\n\nExample:\n\nMODEL:\n    broadcast probability=per_source","category":"section"},{"location":"guides/dsl/#Process-Specific-Models","page":"Protocol DSL","title":"Process-Specific Models","text":"MODEL:\n    process <id>: <model_spec>\n    process <id>: <model_spec>\n    ...\n\nAssign different models to different processes.\n\nExample:\n\nMODEL:\n    process 1: standard\n    process 2: broadcast\n    process 3: guaranteed k=2 scope=per_round\n\nSee Delivery Models Guide for details.\n\n","category":"section"},{"location":"guides/dsl/#UPDATE-RULE","page":"Protocol DSL","title":"UPDATE RULE","text":"UPDATE RULE:\n    <PHASE>:\n        <rule>\n\nRequired. Defines how processes update their state.","category":"section"},{"location":"guides/dsl/#Phases","page":"Protocol DSL","title":"Phases","text":"EACH ROUND - Execute every round\nEND - Execute once after all rounds\nFIRST ROUND - Execute only in round 1\nAFTER ROUNDS <k> - Execute starting from round k+1\nUNTIL CONSENSUS - Execute until consensus is reached\n\nExample:\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\n    END:\n        x·µ¢ ‚Üê min(inbox_with_self)","category":"section"},{"location":"guides/dsl/#Update-Rules","page":"Protocol DSL","title":"Update Rules","text":"Simple Assignment:\n\nx·µ¢ ‚Üê <expression>\n\nConditional:\n\nif <condition> then\n    x·µ¢ ‚Üê <expr1>\nelse\n    x·µ¢ ‚Üê <expr2>\nend\n\nConditions:\n\nreceived_diff - Inbox contains value different from own\nreceived_any - Inbox is not empty\nreceived_all - Received message from all other processes\nreceived_at_least(k) - Received at least k messages\nreceived_majority - Received from majority\n\nArithmetic:\n\nx·µ¢ ‚Üê x + 1\nx·µ¢ ‚Üê x * 2 + y\nx·µ¢ ‚Üê (x + sum(inbox)) / 2\n\nAggregations:\n\navg(inbox) - Average of received values\navg(inbox_with_self) - Average including own value\nsum(inbox) - Sum of received values\nmin(inbox) - Minimum of received values\nmax(inbox) - Maximum of received values\ncount(inbox) - Number of messages received\n\nSpecial Values:\n\nx or self - Own current value\ny - Parameter (if defined)\nreceived_other_value - A different value from inbox (for FV-like protocols)\n\nExample:\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then\n            x·µ¢ ‚Üê y\n        else\n            x·µ¢ ‚Üê x\n        end\n\n","category":"section"},{"location":"guides/dsl/#METRICS","page":"Protocol DSL","title":"METRICS","text":"METRICS:\n    <metric1>\n    <metric2>\n\nOptional. Defaults to discrepancy and consensus if omitted.\n\nSupported Metrics:\n\ndiscrepancy - max(x) - min(x)\nconsensus - Whether all processes agree (within Œµ)\n\nExample:\n\nMETRICS:\n    discrepancy\n    consensus\n\n","category":"section"},{"location":"guides/dsl/#Complete-Examples","page":"Protocol DSL","title":"Complete Examples","text":"","category":"section"},{"location":"guides/dsl/#Example-1:-AMP-Protocol","page":"Protocol DSL","title":"Example 1: AMP Protocol","text":"Protocol(\"\"\"\nPROTOCOL AMP\nPROCESSES: 2\nSTATE:\n    x ‚àà {0,1}\nINITIAL VALUES:\n    [0.0, 1.0]\nPARAMETERS:\n    y ‚àà [0,1] = 0.5\nCHANNEL:\n    stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then\n            x·µ¢ ‚Üê y\n        else\n            x·µ¢ ‚Üê x\n        end\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")","category":"section"},{"location":"guides/dsl/#Example-2:-Simple-Averaging","page":"Protocol DSL","title":"Example 2: Simple Averaging","text":"Protocol(\"\"\"\nPROTOCOL Averaging\nPROCESSES: 10\nSTATE:\n    x ‚àà ‚Ñù\nINITIAL:\n    x·µ¢ = i\nCHANNEL:\n    stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")","category":"section"},{"location":"guides/dsl/#Example-3:-Minimum-with-Broadcast","page":"Protocol DSL","title":"Example 3: Minimum with Broadcast","text":"Protocol(\"\"\"\nPROTOCOL MinProtocol\nPROCESSES: 5\nSTATE:\n    x ‚àà ‚Ñù\nINITIAL VALUES:\n    [5.0, 3.0, 8.0, 1.0, 6.0]\nCHANNEL:\n    stochastic\n\nMODEL:\n    broadcast probability=per_source\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_any then\n            x·µ¢ ‚Üê min(inbox_with_self)\n        else\n            x·µ¢ ‚Üê x\n        end\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\n","category":"section"},{"location":"guides/dsl/#Advanced-Features","page":"Protocol DSL","title":"Advanced Features","text":"","category":"section"},{"location":"guides/dsl/#Complex-Expressions","page":"Protocol DSL","title":"Complex Expressions","text":"UPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê (x + avg(inbox)) / 2","category":"section"},{"location":"guides/dsl/#Multiple-Conditions","page":"Protocol DSL","title":"Multiple Conditions","text":"UPDATE RULE:\n    EACH ROUND:\n        if received_majority then\n            x·µ¢ ‚Üê avg(inbox_with_self)\n        else\n            x·µ¢ ‚Üê x\n        end","category":"section"},{"location":"guides/dsl/#Multi-Phase-Updates","page":"Protocol DSL","title":"Multi-Phase Updates","text":"UPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\n    END:\n        x·µ¢ ‚Üê min(inbox_with_self)\n\n","category":"section"},{"location":"guides/dsl/#Tips-and-Best-Practices","page":"Protocol DSL","title":"Tips & Best Practices","text":"Start Simple: Begin with basic protocols before adding complexity\nTest Small: Use PROCESSES: 2 or 3 for initial testing\nUse Parameters: Make protocols configurable with PARAMETERS\nDescriptive Names: Use clear protocol names\nComments: While not officially supported, keep protocol definitions well-structured\n\n","category":"section"},{"location":"guides/dsl/#See-Also","page":"Protocol DSL","title":"See Also","text":"Quick Start - Get started quickly\nDelivery Models - Communication models\nExamples - Real-world protocols\nAPI Reference - Function documentation","category":"section"},{"location":"#StochProtocol.jl","page":"Home","title":"StochProtocol.jl","text":"Beautiful simulation framework for distributed consensus under stochastic communication\n\n","category":"section"},{"location":"#What-is-StochProtocol?","page":"Home","title":"What is StochProtocol?","text":"StochProtocol.jl is a high-level Julia framework that lets you define, simulate, and analyze distributed consensus protocols using clean mathematical notation.\n\nNo boilerplate. No manual message passing. Just pure protocol logic.\n\nusing StochProtocol\n\n# Define a protocol in 30 seconds\nAMP = Protocol(\"\"\"\nPROTOCOL AMP\nPROCESSES: 2\nSTATE: x ‚àà {0,1}\nINITIAL VALUES: [0.0, 1.0]\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        if received_diff then x·µ¢ ‚Üê 0.5 else x·µ¢ ‚Üê x end\n\nMETRICS: discrepancy, consensus\n\"\"\")\n\n# Run 10,000 simulations across probability range\nresults = run_protocol(AMP; p_values=0.0:0.05:1.0, repetitions=2000)\n\n# Beautiful visualizations\nplot_discrepancy_vs_p(results)\nresults_table(results)\n\n","category":"section"},{"location":"#Why-StochProtocol?","page":"Home","title":"Why StochProtocol?","text":"","category":"section"},{"location":"#Declarative-Protocol-Design","page":"Home","title":"Declarative Protocol Design","text":"Write protocols in paper-like mathematical notation. No coding required for protocol logic.","category":"section"},{"location":"#Automatic-Monte-Carlo","page":"Home","title":"Automatic Monte Carlo","text":"Run thousands of randomized experiments automatically. Get statistical distributions with a single function call.","category":"section"},{"location":"#Publication-Ready-Output","page":"Home","title":"Publication-Ready Output","text":"Beautiful interactive tables and plots ready for your papers and presentations.","category":"section"},{"location":"#Research-Grade-Features","page":"Home","title":"Research-Grade Features","text":"Multiple delivery models (standard, guaranteed, broadcast)\nProcess-specific configurations\nMulti-round dynamics tracking\nProtocol comparison tools","category":"section"},{"location":"#Fast-and-Efficient","page":"Home","title":"Fast & Efficient","text":"Optimized Julia core with deterministic RNG for reproducibility. Simulate thousands of runs in seconds.","category":"section"},{"location":"#Flexible-Delivery-Models","page":"Home","title":"Flexible Delivery Models","text":"Standard probabilistic, guaranteed delivery, broadcast semantics, or mix-and-match per process.\n\n","category":"section"},{"location":"#Quick-Example:-Averaging-Protocol","page":"Home","title":"Quick Example: Averaging Protocol","text":"using StochProtocol\n\n# Define the protocol\naveraging = Protocol(\"\"\"\nPROTOCOL SimpleAveraging\nPROCESSES: 10\nSTATE: x ‚àà ‚Ñù\nINITIAL: x·µ¢ = i\nCHANNEL: stochastic\n\nUPDATE RULE:\n    EACH ROUND:\n        x·µ¢ ‚Üê avg(inbox_with_self)\n\nMETRICS:\n    discrepancy\n    consensus\n\"\"\")\n\n# Run experiments\nresults = run_protocol(averaging;\n    p_values = 0.5:0.1:1.0,\n    rounds = 5,\n    repetitions = 1000\n)\n\n# Visualize\nplot_discrepancy_vs_p(results;\n    title = \"Convergence Rate vs Probability\",\n    save_path = \"averaging_results.png\"\n)\n\nOutput: A beautiful plot showing how quickly consensus is reached as communication probability increases.\n\n","category":"section"},{"location":"#Key-Features","page":"Home","title":"Key Features","text":"Feature Description\nProtocol DSL Paper-like syntax with full Julia expressions\nDelivery Models Standard, guaranteed delivery, broadcast, hybrid\nMetrics Discrepancy, consensus probability, custom metrics\nVisualization Built-in plotting and table generation\nMonte Carlo Automatic statistical analysis over thousands of runs\nComparison Side-by-side protocol performance analysis\n\n","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"StochProtocol\")\n\nOr from GitHub:\n\nusing Pkg\nPkg.add(url=\"https://github.com/notGiGi/StochProtocol.jl\")\n\n","category":"section"},{"location":"#Community-and-Support","page":"Home","title":"Community & Support","text":"GitHub: notGiGi/StochProtocol.jl\nIssues: Report bugs or request features\n\n","category":"section"},{"location":"#Citation","page":"Home","title":"Citation","text":"If you use StochProtocol.jl in your research, please cite:\n\n@software{stochprotocol2025,\n  title = {StochProtocol.jl: Simulation of Stochastic Consensus Protocols},\n  author = {notGiGi},\n  year = {2025},\n  url = {https://github.com/notGiGi/StochProtocol.jl}\n}\n\n","category":"section"},{"location":"#License","page":"Home","title":"License","text":"MIT License - Free for academic and commercial use.","category":"section"}]
}
